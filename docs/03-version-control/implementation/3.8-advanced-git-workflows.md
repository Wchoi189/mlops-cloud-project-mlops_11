# 3.8 ê³ ê¸‰ Git ì›Œí¬í”Œë¡œìš°

## ğŸ“‹ ê°œìš”

**ëª©í‘œ**: ëŒ€ê·œëª¨ íŒ€ê³¼ ë³µì¡í•œ í”„ë¡œì íŠ¸ë¥¼ ìœ„í•œ ê³ ê¸‰ Git ê¸°ëŠ¥ í™œìš© ë° ì›Œí¬í”Œë¡œìš° ìµœì í™”
**ì†Œìš” ì‹œê°„**: 3-4ì‹œê°„
**ë‚œì´ë„**: ê³ ê¸‰

WSL Ubuntu í™˜ê²½ì—ì„œ Docker ê¸°ë°˜ìœ¼ë¡œ ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ Git ì›Œí¬í”Œë¡œìš°ì™€ ìë™í™” ì‹œìŠ¤í…œì„ êµ¬ì¶•í•©ë‹ˆë‹¤.

---

## ğŸ¯ 1. Git Hooks ì‹œìŠ¤í…œ êµ¬ì¶•

### 1.1 Pre-commit Hook ì„¤ì •

```bash
# WSL Ubuntu í™˜ê²½ì—ì„œ ì‹¤í–‰
cd /mnt/c/dev/movie-mlops

# pre-commit íŒ¨í‚¤ì§€ ì„¤ì¹˜ í™•ì¸
pip install pre-commit>=4.0.1

# pre-commit ì„¤ì • íŒŒì¼ ìƒì„±
cat > .pre-commit-config.yaml << 'EOF'
# MLOps í”„ë¡œì íŠ¸ìš© pre-commit ì„¤ì •
repos:
  # Python ì½”ë“œ í’ˆì§ˆ
  - repo: https://github.com/psf/black
    rev: 24.10.0
    hooks:
      - id: black
        language_version: python3.11
        args: [--line-length=88]
        
  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks:
      - id: isort
        args: [--profile=black, --line-length=88]
        
  - repo: https://github.com/pycqa/flake8
    rev: 7.1.1
    hooks:
      - id: flake8
        args: [--max-line-length=88, --extend-ignore=E203,W503]
        
  # ì¼ë°˜ì ì¸ ì´ìŠˆ ê²€ì‚¬
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-json
      - id: check-added-large-files
        args: ['--maxkb=10240']  # 10MB ì œí•œ
      - id: check-merge-conflict
      - id: debug-statements
        
  # MLOps íŠ¹í™” ê²€ì‚¬
  - repo: local
    hooks:
      - id: data-validation
        name: ë°ì´í„° íŒŒì¼ ê²€ì¦
        entry: python scripts/hooks/validate_data_files.py
        language: python
        files: ^data/.*\.(json|csv|parquet)$
        pass_filenames: true
        
      - id: config-validation
        name: ì„¤ì • íŒŒì¼ ê²€ì¦
        entry: python scripts/hooks/validate_config_files.py
        language: python
        files: ^config/.*\.yaml$
        pass_filenames: true
EOF

# pre-commit ì„¤ì¹˜
pre-commit install

echo "ğŸ”— Pre-commit hooks ì„¤ì • ì™„ë£Œ"
```

### 1.2 ì»¤ìŠ¤í…€ Git Hook ìŠ¤í¬ë¦½íŠ¸ ìƒì„±

```bash
# Git hooks ë””ë ‰í„°ë¦¬ ìƒì„±
mkdir -p scripts/hooks

# ë°ì´í„° íŒŒì¼ ê²€ì¦ í›…
cat > scripts/hooks/validate_data_files.py << 'EOF'
#!/usr/bin/env python3
"""
ë°ì´í„° íŒŒì¼ ê²€ì¦ Git Hook
"""
import sys
import json
from pathlib import Path

def validate_json_file(file_path: Path) -> bool:
    """JSON íŒŒì¼ ê²€ì¦"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # ê¸°ë³¸ êµ¬ì¡° ê²€ì¦
        if isinstance(data, list) and len(data) > 0:
            print(f"âœ… {file_path}: JSON íŒŒì¼ ê²€ì¦ í†µê³¼ ({len(data)} ë ˆì½”ë“œ)")
            return True
        elif isinstance(data, dict):
            print(f"âœ… {file_path}: JSON íŒŒì¼ ê²€ì¦ í†µê³¼")
            return True
        else:
            print(f"âŒ {file_path}: ë¹ˆ JSON íŒŒì¼ ë˜ëŠ” ì˜ëª»ëœ êµ¬ì¡°")
            return False
            
    except json.JSONDecodeError as e:
        print(f"âŒ {file_path}: JSON íŒŒì‹± ì˜¤ë¥˜ - {e}")
        return False
    except Exception as e:
        print(f"âŒ {file_path}: íŒŒì¼ ì½ê¸° ì˜¤ë¥˜ - {e}")
        return False

def main():
    """ë©”ì¸ ê²€ì¦ í•¨ìˆ˜"""
    if len(sys.argv) < 2:
        print("â„¹ï¸  ê²€ì¦í•  ë°ì´í„° íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
        sys.exit(0)
    
    all_valid = True
    
    for file_path_str in sys.argv[1:]:
        file_path = Path(file_path_str)
        
        if not file_path.exists():
            print(f"âŒ {file_path}: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤")
            all_valid = False
            continue
        
        # íŒŒì¼ í¬ê¸° ê²€ì‚¬ (10MB ì œí•œ)
        file_size_mb = file_path.stat().st_size / (1024 * 1024)
        if file_size_mb > 10:
            print(f"âš ï¸  {file_path}: í° íŒŒì¼ ê°ì§€ ({file_size_mb:.1f}MB)")
            print(f"   DVCë¡œ ê´€ë¦¬í•˜ëŠ” ê²ƒì„ ê³ ë ¤í•´ë³´ì„¸ìš”.")
        
        # íŒŒì¼ í™•ì¥ìë³„ ê²€ì¦
        suffix = file_path.suffix.lower()
        
        if suffix == '.json':
            if not validate_json_file(file_path):
                all_valid = False
        else:
            print(f"â„¹ï¸  {file_path}: ê²€ì¦ ì§€ì›ë˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹")
    
    if not all_valid:
        print("\nâŒ ì¼ë¶€ ë°ì´í„° íŒŒì¼ ê²€ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
        sys.exit(1)
    else:
        print("\nâœ… ëª¨ë“  ë°ì´í„° íŒŒì¼ ê²€ì¦ì„ í†µê³¼í–ˆìŠµë‹ˆë‹¤.")

if __name__ == "__main__":
    main()
EOF

# ì„¤ì • íŒŒì¼ ê²€ì¦ í›…
cat > scripts/hooks/validate_config_files.py << 'EOF'
#!/usr/bin/env python3
"""
ì„¤ì • íŒŒì¼ ê²€ì¦ Git Hook
"""
import sys
import yaml
from pathlib import Path

def validate_yaml_file(file_path: Path) -> bool:
    """YAML íŒŒì¼ ê²€ì¦"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
        
        if data is not None:
            print(f"âœ… {file_path}: YAML íŒŒì¼ ê²€ì¦ í†µê³¼")
            return True
        else:
            print(f"âš ï¸  {file_path}: ë¹ˆ YAML íŒŒì¼")
            return True  # ë¹ˆ íŒŒì¼ë„ í—ˆìš©
            
    except yaml.YAMLError as e:
        print(f"âŒ {file_path}: YAML íŒŒì‹± ì˜¤ë¥˜ - {e}")
        return False
    except Exception as e:
        print(f"âŒ {file_path}: íŒŒì¼ ì½ê¸° ì˜¤ë¥˜ - {e}")
        return False

def main():
    """ë©”ì¸ ê²€ì¦ í•¨ìˆ˜"""
    if len(sys.argv) < 2:
        print("â„¹ï¸  ê²€ì¦í•  ì„¤ì • íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
        sys.exit(0)
    
    all_valid = True
    
    for file_path_str in sys.argv[1:]:
        file_path = Path(file_path_str)
        
        if not file_path.exists():
            print(f"âŒ {file_path}: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤")
            all_valid = False
            continue
        
        if not validate_yaml_file(file_path):
            all_valid = False
    
    if not all_valid:
        print("\nâŒ ì¼ë¶€ ì„¤ì • íŒŒì¼ ê²€ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
        sys.exit(1)
    else:
        print("\nâœ… ëª¨ë“  ì„¤ì • íŒŒì¼ ê²€ì¦ì„ í†µê³¼í–ˆìŠµë‹ˆë‹¤.")

if __name__ == "__main__":
    main()
EOF

# ì‹¤í–‰ ê¶Œí•œ ì„¤ì •
chmod +x scripts/hooks/validate_data_files.py
chmod +x scripts/hooks/validate_config_files.py

echo "ğŸ”§ ì»¤ìŠ¤í…€ Git Hook ìŠ¤í¬ë¦½íŠ¸ ìƒì„± ì™„ë£Œ"
```

---

## ğŸ¯ 2. ê³ ê¸‰ ë¸Œëœì¹˜ ê´€ë¦¬ ì „ëµ

### 2.1 ë¸Œëœì¹˜ ìë™í™” ìŠ¤í¬ë¦½íŠ¸

```bash
# ë¸Œëœì¹˜ ê´€ë¦¬ ìë™í™” ìŠ¤í¬ë¦½íŠ¸
cat > scripts/git_branch_manager.py << 'EOF'
#!/usr/bin/env python3
"""
ê³ ê¸‰ Git ë¸Œëœì¹˜ ê´€ë¦¬ ë„êµ¬
"""
import subprocess
import sys
import argparse
from datetime import datetime
from typing import List, Dict, Optional

class GitBranchManager:
    """Git ë¸Œëœì¹˜ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.current_branch = self._get_current_branch()
        self.all_branches = self._get_all_branches()
    
    def _run_git_command(self, cmd: List[str]) -> str:
        """Git ëª…ë ¹ì–´ ì‹¤í–‰"""
        try:
            result = subprocess.run(
                ['git'] + cmd,
                capture_output=True,
                text=True,
                check=True
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError as e:
            print(f"âŒ Git ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨: {' '.join(cmd)}")
            print(f"   ì˜¤ë¥˜: {e.stderr}")
            sys.exit(1)
    
    def _get_current_branch(self) -> str:
        """í˜„ì¬ ë¸Œëœì¹˜ ê°€ì ¸ì˜¤ê¸°"""
        return self._run_git_command(['branch', '--show-current'])
    
    def _get_all_branches(self) -> List[str]:
        """ëª¨ë“  ë¸Œëœì¹˜ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°"""
        output = self._run_git_command(['branch', '-a'])
        branches = []
        for line in output.split('\n'):
            branch = line.strip().replace('* ', '').replace('remotes/origin/', '')
            if branch and not branch.startswith('HEAD'):
                branches.append(branch)
        return list(set(branches))  # ì¤‘ë³µ ì œê±°
    
    def create_feature_branch(self, issue_number: str, description: str) -> str:
        """ê¸°ëŠ¥ ë¸Œëœì¹˜ ìƒì„±"""
        branch_name = f"feature/{issue_number}-{description}"
        
        print(f"ğŸŒ¿ ê¸°ëŠ¥ ë¸Œëœì¹˜ ìƒì„±: {branch_name}")
        
        # mainì—ì„œ ìµœì‹  ìƒíƒœë¡œ ì—…ë°ì´íŠ¸
        self._run_git_command(['checkout', 'main'])
        self._run_git_command(['pull', 'origin', 'main'])
        
        # ìƒˆ ë¸Œëœì¹˜ ìƒì„± ë° ì²´í¬ì•„ì›ƒ
        self._run_git_command(['checkout', '-b', branch_name])
        
        print(f"âœ… ë¸Œëœì¹˜ '{branch_name}' ìƒì„± ì™„ë£Œ")
        return branch_name
    
    def create_hotfix_branch(self, issue_number: str, description: str) -> str:
        """í•«í”½ìŠ¤ ë¸Œëœì¹˜ ìƒì„±"""
        branch_name = f"hotfix/{issue_number}-{description}"
        
        print(f"ğŸ”¥ í•«í”½ìŠ¤ ë¸Œëœì¹˜ ìƒì„±: {branch_name}")
        
        # mainì—ì„œ ìµœì‹  ìƒíƒœë¡œ ì—…ë°ì´íŠ¸
        self._run_git_command(['checkout', 'main'])
        self._run_git_command(['pull', 'origin', 'main'])
        
        # ìƒˆ ë¸Œëœì¹˜ ìƒì„± ë° ì²´í¬ì•„ì›ƒ
        self._run_git_command(['checkout', '-b', branch_name])
        
        print(f"âœ… í•«í”½ìŠ¤ ë¸Œëœì¹˜ '{branch_name}' ìƒì„± ì™„ë£Œ")
        return branch_name
    
    def cleanup_merged_branches(self, dry_run: bool = True) -> List[str]:
        """ë³‘í•©ëœ ë¸Œëœì¹˜ ì •ë¦¬"""
        print("ğŸ§¹ ë³‘í•©ëœ ë¸Œëœì¹˜ ì •ë¦¬ ì¤‘...")
        
        # ë³‘í•©ëœ ë¸Œëœì¹˜ ì°¾ê¸°
        merged_output = self._run_git_command(['branch', '--merged', 'main'])
        merged_branches = []
        
        for line in merged_output.split('\n'):
            branch = line.strip().replace('* ', '')
            if branch and branch not in ['main', 'master', 'develop']:
                merged_branches.append(branch)
        
        if not merged_branches:
            print("â„¹ï¸  ì •ë¦¬í•  ë³‘í•©ëœ ë¸Œëœì¹˜ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return []
        
        print(f"ğŸ“‹ ë³‘í•©ëœ ë¸Œëœì¹˜ ëª©ë¡:")
        for branch in merged_branches:
            print(f"  - {branch}")
        
        if dry_run:
            print("\nğŸ” Dry run ëª¨ë“œ: ì‹¤ì œë¡œ ì‚­ì œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            print("   ì‹¤ì œ ì‚­ì œë¥¼ ìœ„í•´ì„œëŠ” --execute ì˜µì…˜ì„ ì‚¬ìš©í•˜ì„¸ìš”.")
        else:
            print("\nâ“ ì´ ë¸Œëœì¹˜ë“¤ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/N)")
            response = input().strip().lower()
            if response == 'y':
                for branch in merged_branches:
                    try:
                        self._run_git_command(['branch', '-d', branch])
                        print(f"  âœ… ì‚­ì œë¨: {branch}")
                    except:
                        print(f"  âŒ ì‚­ì œ ì‹¤íŒ¨: {branch}")
            else:
                print("â­ï¸  ë¸Œëœì¹˜ ì‚­ì œë¥¼ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
        
        return merged_branches
    
    def list_branch_status(self) -> Dict[str, Dict]:
        """ë¸Œëœì¹˜ ìƒíƒœ ì •ë³´ ì¶œë ¥"""
        print("ğŸ“Š ë¸Œëœì¹˜ ìƒíƒœ ì •ë³´:")
        print(f"  í˜„ì¬ ë¸Œëœì¹˜: {self.current_branch}")
        print(f"  ì „ì²´ ë¸Œëœì¹˜ ìˆ˜: {len(self.all_branches)}")
        
        # ë¸Œëœì¹˜ íƒ€ì…ë³„ ë¶„ë¥˜
        feature_branches = [b for b in self.all_branches if b.startswith('feature/')]
        bugfix_branches = [b for b in self.all_branches if b.startswith('bugfix/')]
        hotfix_branches = [b for b in self.all_branches if b.startswith('hotfix/')]
        
        print(f"  ê¸°ëŠ¥ ë¸Œëœì¹˜: {len(feature_branches)}")
        print(f"  ë²„ê·¸í”½ìŠ¤ ë¸Œëœì¹˜: {len(bugfix_branches)}")
        print(f"  í•«í”½ìŠ¤ ë¸Œëœì¹˜: {len(hotfix_branches)}")
        
        return {
            'current': self.current_branch,
            'all': self.all_branches,
            'feature': feature_branches,
            'bugfix': bugfix_branches,
            'hotfix': hotfix_branches
        }

def main():
    parser = argparse.ArgumentParser(description="ê³ ê¸‰ Git ë¸Œëœì¹˜ ê´€ë¦¬ ë„êµ¬")
    subparsers = parser.add_subparsers(dest='command', help='ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´')
    
    # feature ë¸Œëœì¹˜ ìƒì„±
    feature_parser = subparsers.add_parser('feature', help='ê¸°ëŠ¥ ë¸Œëœì¹˜ ìƒì„±')
    feature_parser.add_argument('issue', help='ì´ìŠˆ ë²ˆí˜¸')
    feature_parser.add_argument('description', help='ë¸Œëœì¹˜ ì„¤ëª…')
    
    # hotfix ë¸Œëœì¹˜ ìƒì„±
    hotfix_parser = subparsers.add_parser('hotfix', help='í•«í”½ìŠ¤ ë¸Œëœì¹˜ ìƒì„±')
    hotfix_parser.add_argument('issue', help='ì´ìŠˆ ë²ˆí˜¸')
    hotfix_parser.add_argument('description', help='ë¸Œëœì¹˜ ì„¤ëª…')
    
    # ë¸Œëœì¹˜ ì •ë¦¬
    cleanup_parser = subparsers.add_parser('cleanup', help='ë³‘í•©ëœ ë¸Œëœì¹˜ ì •ë¦¬')
    cleanup_parser.add_argument('--execute', action='store_true', help='ì‹¤ì œë¡œ ì‚­ì œ ì‹¤í–‰')
    
    # ë¸Œëœì¹˜ ìƒíƒœ
    subparsers.add_parser('status', help='ë¸Œëœì¹˜ ìƒíƒœ ì •ë³´')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    manager = GitBranchManager()
    
    if args.command == 'feature':
        manager.create_feature_branch(args.issue, args.description)
    elif args.command == 'hotfix':
        manager.create_hotfix_branch(args.issue, args.description)
    elif args.command == 'cleanup':
        manager.cleanup_merged_branches(dry_run=not args.execute)
    elif args.command == 'status':
        manager.list_branch_status()

if __name__ == "__main__":
    main()
EOF

chmod +x scripts/git_branch_manager.py

echo "ğŸŒ¿ ë¸Œëœì¹˜ ê´€ë¦¬ ìŠ¤í¬ë¦½íŠ¸ ìƒì„± ì™„ë£Œ"
```

---

## ğŸ¯ 3. Git LFS (Large File Storage) ì„¤ì •

### 3.1 Git LFS ì„¤ì • ë° êµ¬ì„±

```bash
# Git LFS ì„¤ì¹˜ í™•ì¸ (WSL Ubuntu)
if ! command -v git-lfs &> /dev/null; then
    echo "ğŸ“¦ Git LFS ì„¤ì¹˜ ì¤‘..."
    curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash
    sudo apt-get install git-lfs
fi

# Git LFS ì´ˆê¸°í™”
git lfs install

# MLOps í”„ë¡œì íŠ¸ìš© LFS ì¶”ì  ì„¤ì •
echo "ğŸ“ ëŒ€ìš©ëŸ‰ íŒŒì¼ ì¶”ì  ì„¤ì •..."

# ë°ì´í„° íŒŒì¼
git lfs track "*.parquet"
git lfs track "*.pkl"
git lfs track "*.joblib"
git lfs track "*.h5"
git lfs track "*.hdf5"
git lfs track "*.model"

# ëª¨ë¸ íŒŒì¼
git lfs track "models/*.pkl"
git lfs track "models/*.h5"
git lfs track "models/*.onnx"
git lfs track "models/*.pb"

# ëŒ€ìš©ëŸ‰ ì••ì¶• íŒŒì¼
git lfs track "*.zip"
git lfs track "*.tar.gz"
git lfs track "*.7z"

# ë¯¸ë””ì–´ íŒŒì¼
git lfs track "*.mp4"
git lfs track "*.avi"
git lfs track "*.mkv"

# .gitattributes íŒŒì¼ ì»¤ë°‹
git add .gitattributes
git commit -m "config: setup Git LFS tracking for large files

- Track data files (parquet, pkl, joblib, h5)
- Track model files (h5, onnx, pb)
- Track compressed archives
- Track media files" || echo "â„¹ï¸  ì´ë¯¸ ì»¤ë°‹ëœ ìƒíƒœì…ë‹ˆë‹¤."

echo "âœ… Git LFS ì„¤ì • ì™„ë£Œ"
```

### 3.2 LFS ê´€ë¦¬ ìŠ¤í¬ë¦½íŠ¸

```bash
# Git LFS ê´€ë¦¬ ìŠ¤í¬ë¦½íŠ¸
cat > scripts/git_lfs_manager.py << 'EOF'
#!/usr/bin/env python3
"""
Git LFS ê´€ë¦¬ ë„êµ¬
"""
import subprocess
import sys
import os
from pathlib import Path
from typing import List, Dict

class GitLFSManager:
    """Git LFS ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def check_lfs_status(self) -> Dict:
        """LFS ìƒíƒœ í™•ì¸"""
        try:
            # LFS íŒŒì¼ ëª©ë¡
            result = subprocess.run(
                ['git', 'lfs', 'ls-files'],
                capture_output=True,
                text=True,
                check=True
            )
            lfs_files = result.stdout.strip().split('\n') if result.stdout.strip() else []
            
            # LFS ì¶”ì  íŒ¨í„´
            result = subprocess.run(
                ['git', 'lfs', 'track'],
                capture_output=True,
                text=True,
                check=True
            )
            tracked_patterns = result.stdout.strip().split('\n') if result.stdout.strip() else []
            
            return {
                'files': [f for f in lfs_files if f],
                'patterns': [p.strip() for p in tracked_patterns if p.strip()]
            }
        except subprocess.CalledProcessError:
            return {'files': [], 'patterns': []}
    
    def find_large_files(self, size_mb: float = 10.0) -> List[Dict]:
        """ì§€ì •ëœ í¬ê¸° ì´ìƒì˜ íŒŒì¼ ì°¾ê¸°"""
        large_files = []
        
        for root, dirs, files in os.walk('.'):
            # .git ë””ë ‰í„°ë¦¬ ì œì™¸
            if '.git' in dirs:
                dirs.remove('.git')
            
            for file in files:
                file_path = Path(root) / file
                try:
                    size_mb_actual = file_path.stat().st_size / (1024 * 1024)
                    if size_mb_actual >= size_mb:
                        large_files.append({
                            'path': str(file_path),
                            'size_mb': round(size_mb_actual, 2)
                        })
                except (OSError, PermissionError):
                    continue
        
        return sorted(large_files, key=lambda x: x['size_mb'], reverse=True)
    
    def print_status(self):
        """LFS ìƒíƒœ ì¶œë ¥"""
        print("ğŸ“Š Git LFS ìƒíƒœ:")
        
        status = self.check_lfs_status()
        
        print(f"  ì¶”ì  ì¤‘ì¸ íŒ¨í„´: {len(status['patterns'])}")
        for pattern in status['patterns'][:10]:  # ìµœëŒ€ 10ê°œë§Œ í‘œì‹œ
            print(f"    - {pattern}")
        if len(status['patterns']) > 10:
            print(f"    ... ë° {len(status['patterns']) - 10}ê°œ ë”")
        
        print(f"  LFSë¡œ ê´€ë¦¬ë˜ëŠ” íŒŒì¼: {len(status['files'])}")
        for lfs_file in status['files'][:5]:  # ìµœëŒ€ 5ê°œë§Œ í‘œì‹œ
            print(f"    - {lfs_file}")
        if len(status['files']) > 5:
            print(f"    ... ë° {len(status['files']) - 5}ê°œ ë”")
    
    def suggest_lfs_candidates(self, size_mb: float = 10.0):
        """LFS í›„ë³´ íŒŒì¼ ì œì•ˆ"""
        large_files = self.find_large_files(size_mb)
        status = self.check_lfs_status()
        
        # ì´ë¯¸ LFSë¡œ ê´€ë¦¬ë˜ëŠ” íŒŒì¼ ì œì™¸
        lfs_managed = [f.split()[-1] for f in status['files']]
        candidates = [f for f in large_files if f['path'] not in lfs_managed]
        
        if not candidates:
            print(f"âœ… {size_mb}MB ì´ìƒì˜ LFS í›„ë³´ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
            return
        
        print(f"ğŸ“‹ LFS ê´€ë¦¬ ê¶Œì¥ íŒŒì¼ë“¤ ({size_mb}MB ì´ìƒ):")
        for file_info in candidates[:10]:  # ìµœëŒ€ 10ê°œë§Œ í‘œì‹œ
            print(f"  - {file_info['path']} ({file_info['size_mb']}MB)")
        
        if len(candidates) > 10:
            print(f"  ... ë° {len(candidates) - 10}ê°œ ë”")
        
        print("\nğŸ’¡ LFS ì¶”ì  ì¶”ê°€ ë°©ë²•:")
        print("   git lfs track \"path/to/file\" ë˜ëŠ”")
        print("   git lfs track \"*.extension\"")

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description="Git LFS ê´€ë¦¬ ë„êµ¬")
    subparsers = parser.add_subparsers(dest='command', help='ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´')
    
    # ìƒíƒœ í™•ì¸
    subparsers.add_parser('status', help='LFS ìƒíƒœ í™•ì¸')
    
    # ëŒ€ìš©ëŸ‰ íŒŒì¼ ì°¾ê¸°
    suggest_parser = subparsers.add_parser('suggest', help='LFS í›„ë³´ íŒŒì¼ ì œì•ˆ')
    suggest_parser.add_argument('--size', type=float, default=10.0, help='ìµœì†Œ íŒŒì¼ í¬ê¸° (MB)')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    manager = GitLFSManager()
    
    if args.command == 'status':
        manager.print_status()
    elif args.command == 'suggest':
        manager.suggest_lfs_candidates(args.size)

if __name__ == "__main__":
    main()
EOF

chmod +x scripts/git_lfs_manager.py

echo "ğŸ“¦ Git LFS ê´€ë¦¬ ìŠ¤í¬ë¦½íŠ¸ ìƒì„± ì™„ë£Œ"
```

---

## ğŸ¯ 4. ìë™í™”ëœ ì›Œí¬í”Œë¡œìš° ìŠ¤í¬ë¦½íŠ¸

### 4.1 í†µí•© Git ì›Œí¬í”Œë¡œìš° ìŠ¤í¬ë¦½íŠ¸

```bash
# í†µí•© Git ì›Œí¬í”Œë¡œìš° ìë™í™” ìŠ¤í¬ë¦½íŠ¸
cat > scripts/git_workflow_automation.py << 'EOF'
#!/usr/bin/env python3
"""
MLOps í”„ë¡œì íŠ¸ìš© Git ì›Œí¬í”Œë¡œìš° ìë™í™” ë„êµ¬
"""
import subprocess
import sys
import os
import argparse
from datetime import datetime
from pathlib import Path

class MLOpsGitWorkflow:
    """MLOps Git ì›Œí¬í”Œë¡œìš° ìë™í™” í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.project_root = Path.cwd()
        self.current_branch = self._get_current_branch()
    
    def _run_command(self, cmd: list, check: bool = True) -> subprocess.CompletedProcess:
        """ëª…ë ¹ì–´ ì‹¤í–‰"""
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=check)
            return result
        except subprocess.CalledProcessError as e:
            print(f"âŒ ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨: {' '.join(cmd)}")
            print(f"   ì˜¤ë¥˜: {e.stderr}")
            if check:
                sys.exit(1)
            return e
    
    def _get_current_branch(self) -> str:
        """í˜„ì¬ ë¸Œëœì¹˜ ê°€ì ¸ì˜¤ê¸°"""
        result = self._run_command(['git', 'branch', '--show-current'])
        return result.stdout.strip()
    
    def stage_development_workflow(self, stage: str, feature: str):
        """MLOps ë‹¨ê³„ë³„ ê°œë°œ ì›Œí¬í”Œë¡œìš°"""
        print(f"ğŸš€ MLOps {stage}ë‹¨ê³„ ê°œë°œ ì›Œí¬í”Œë¡œìš° ì‹œì‘: {feature}")
        
        # 1. ê¸°ëŠ¥ ë¸Œëœì¹˜ ìƒì„±
        branch_name = f"feature/stage{stage}-{feature}"
        print(f"\nğŸŒ¿ 1. ê¸°ëŠ¥ ë¸Œëœì¹˜ ìƒì„±: {branch_name}")
        
        # mainì—ì„œ ìµœì‹  ìƒíƒœë¡œ ì—…ë°ì´íŠ¸
        self._run_command(['git', 'checkout', 'main'])
        self._run_command(['git', 'pull', 'origin', 'main'])
        
        # ìƒˆ ë¸Œëœì¹˜ ìƒì„±
        self._run_command(['git', 'checkout', '-b', branch_name])
        
        # 2. ë””ë ‰í„°ë¦¬ êµ¬ì¡° ìƒì„±
        stage_dir = f"docs/{stage.zfill(2)}-{feature.replace('_', '-')}"
        impl_dir = f"{stage_dir}/implementation"
        
        print(f"\nğŸ“ 2. í”„ë¡œì íŠ¸ êµ¬ì¡° ìƒì„±: {stage_dir}")
        Path(impl_dir).mkdir(parents=True, exist_ok=True)
        
        # 3. ê¸°ë³¸ íŒŒì¼ ìƒì„±
        readme_content = f"""# {stage}ë‹¨ê³„: {feature.replace('_', ' ').title()}

## ğŸ“‹ ê°œìš”

**ëª©í‘œ**: MLOps {stage}ë‹¨ê³„ {feature} êµ¬í˜„
**ì†Œìš” ì‹œê°„**: ì˜ˆìƒ ì‹œê°„
**ë‚œì´ë„**: ì¤‘ê¸‰

## ğŸ¯ êµ¬í˜„ ì‚¬í•­

### ì£¼ìš” ê¸°ëŠ¥
- ê¸°ëŠ¥ 1
- ê¸°ëŠ¥ 2
- ê¸°ëŠ¥ 3

## ğŸ“Š ì™„ë£Œ ê¸°ì¤€

- [ ] ê¸°ëŠ¥ì  ì™„ë£Œ ê¸°ì¤€
- [ ] ê¸°ìˆ ì  ì™„ë£Œ ê¸°ì¤€
- [ ] ë¬¸ì„œí™” ì™„ë£Œ

## ğŸ”— ê´€ë ¨ ë¬¸ì„œ

- [ì „ì²´ ì•„í‚¤í…ì²˜](../00-overview/0.mlops-architecture-complete-9stages.md)
- [êµ¬í˜„ ë¡œë“œë§µ](../00-overview/7.mlops-9-stages-implementation-roadmap.md)
"""
        
        with open(f"{stage_dir}/README.md", 'w', encoding='utf-8') as f:
            f.write(readme_content)
        
        print(f"âœ… ê°œë°œ í™˜ê²½ ì„¤ì • ì™„ë£Œ")
        print(f"\nğŸ“ ë‹¤ìŒ ë‹¨ê³„:")
        print(f"   1. {stage_dir}/implementation/ í´ë”ì—ì„œ êµ¬í˜„ ì‹œì‘")
        print(f"   2. ì •ê¸°ì ìœ¼ë¡œ ì»¤ë°‹ ìˆ˜í–‰")
        print(f"   3. ì™„ë£Œ í›„ PR ìƒì„±")
        
        return branch_name
    
    def pre_commit_check(self):
        """ì»¤ë°‹ ì „ ê²€ì‚¬"""
        print("ğŸ” ì»¤ë°‹ ì „ ê²€ì‚¬ ì‹œì‘...")
        
        # 1. pre-commit ì‹¤í–‰
        print("\n1. Pre-commit hooks ì‹¤í–‰...")
        result = self._run_command(['pre-commit', 'run', '--all-files'], check=False)
        
        if result.returncode != 0:
            print("âŒ Pre-commit ê²€ì‚¬ ì‹¤íŒ¨")
            print("   ë¬¸ì œë¥¼ í•´ê²°í•œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.")
            return False
        
        # 2. í…ŒìŠ¤íŠ¸ ì‹¤í–‰ (ìˆëŠ” ê²½ìš°)
        if Path('tests').exists():
            print("\n2. í…ŒìŠ¤íŠ¸ ì‹¤í–‰...")
            result = self._run_command(['python', '-m', 'pytest', 'tests/', '-v'], check=False)
            
            if result.returncode != 0:
                print("âŒ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨")
                print("   í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜ì •í•œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.")
                return False
        
        # 3. ë¬¸ì„œí™” ê²€ì‚¬
        print("\n3. ë¬¸ì„œí™” ê²€ì‚¬...")
        if not Path('README.md').exists():
            print("âš ï¸  README.md íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
        
        print("âœ… ëª¨ë“  ê²€ì‚¬ë¥¼ í†µê³¼í–ˆìŠµë‹ˆë‹¤!")
        return True
    
    def create_pull_request_info(self):
        """PR ìƒì„± ì •ë³´ ì¶œë ¥"""
        print("\nğŸ“ Pull Request ìƒì„± ê°€ì´ë“œ:")
        print(f"   í˜„ì¬ ë¸Œëœì¹˜: {self.current_branch}")
        print(f"   ëŒ€ìƒ ë¸Œëœì¹˜: main")
        
        # ë³€ê²½ëœ íŒŒì¼ ëª©ë¡
        result = self._run_command(['git', 'diff', '--name-only', 'main'], check=False)
        if result.stdout:
            print(f"\nğŸ“‹ ë³€ê²½ëœ íŒŒì¼ë“¤:")
            for file in result.stdout.strip().split('\n'):
                if file:
                    print(f"   - {file}")
        
        # ì»¤ë°‹ ë©”ì‹œì§€ ì œì•ˆ
        if 'stage' in self.current_branch and 'feature' in self.current_branch:
            parts = self.current_branch.split('-')
            if len(parts) >= 2:
                stage = parts[0].replace('feature/stage', '')
                feature = '-'.join(parts[1:])
                print(f"\nğŸ’¡ ì œì•ˆ PR ì œëª©:")
                print(f"   feat(stage{stage}): implement {feature.replace('-', ' ')}")
        
        print(f"\nğŸ”— PR ìƒì„± ëª…ë ¹ì–´:")
        print(f"   git push origin {self.current_branch}")
        print(f"   # ê·¸ í›„ GitHubì—ì„œ PR ìƒì„±")

def main():
    parser = argparse.ArgumentParser(description="MLOps Git ì›Œí¬í”Œë¡œìš° ìë™í™”")
    subparsers = parser.add_subparsers(dest='command', help='ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´')
    
    # ë‹¨ê³„ë³„ ê°œë°œ ì‹œì‘
    stage_parser = subparsers.add_parser('start-stage', help='MLOps ë‹¨ê³„ ê°œë°œ ì‹œì‘')
    stage_parser.add_argument('stage', help='ë‹¨ê³„ ë²ˆí˜¸ (ì˜ˆ: 4)')
    stage_parser.add_argument('feature', help='ê¸°ëŠ¥ ì´ë¦„ (ì˜ˆ: cicd_pipeline)')
    
    # ì»¤ë°‹ ì „ ê²€ì‚¬
    subparsers.add_parser('pre-commit', help='ì»¤ë°‹ ì „ ê²€ì‚¬ ì‹¤í–‰')
    
    # PR ì •ë³´
    subparsers.add_parser('pr-info', help='PR ìƒì„± ì •ë³´ ì¶œë ¥')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    workflow = MLOpsGitWorkflow()
    
    if args.command == 'start-stage':
        workflow.stage_development_workflow(args.stage, args.feature)
    elif args.command == 'pre-commit':
        workflow.pre_commit_check()
    elif args.command == 'pr-info':
        workflow.create_pull_request_info()

if __name__ == "__main__":
    main()
EOF

chmod +x scripts/git_workflow_automation.py

echo "âš™ï¸ í†µí•© Git ì›Œí¬í”Œë¡œìš° ìŠ¤í¬ë¦½íŠ¸ ìƒì„± ì™„ë£Œ"
```

---

## ğŸ¯ 5. ì„±ëŠ¥ ìµœì í™” ë° ëª¨ë‹ˆí„°ë§

### 5.1 Git ì„±ëŠ¥ ìµœì í™” ì„¤ì •

```bash
# Git ì„±ëŠ¥ ìµœì í™” ì„¤ì •
echo "âš¡ Git ì„±ëŠ¥ ìµœì í™” ì„¤ì •..."

# Git ì„¤ì • ìµœì í™”
git config core.preloadindex true
git config core.fscache true
git config gc.auto 256

# ëŒ€ìš©ëŸ‰ ì €ì¥ì†Œ ìµœì í™”
git config pack.threads 0
git config pack.deltaCacheSize 2g
git config pack.windowMemory 2g

# WSL í™˜ê²½ ìµœì í™”
git config core.autocrlf false
git config core.filemode false

echo "âœ… Git ì„±ëŠ¥ ìµœì í™” ì™„ë£Œ"
```

### 5.2 Git ìƒíƒœ ëª¨ë‹ˆí„°ë§ ìŠ¤í¬ë¦½íŠ¸

```bash
# Git ì €ì¥ì†Œ ìƒíƒœ ëª¨ë‹ˆí„°ë§ ìŠ¤í¬ë¦½íŠ¸
cat > scripts/git_health_monitor.py << 'EOF'
#!/usr/bin/env python3
"""
Git ì €ì¥ì†Œ ê±´ê°• ìƒíƒœ ëª¨ë‹ˆí„°ë§
"""
import subprocess
import json
import os
from datetime import datetime
from pathlib import Path

class GitHealthMonitor:
    """Git ì €ì¥ì†Œ ê±´ê°• ìƒíƒœ ëª¨ë‹ˆí„°ë§ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.repo_path = Path.cwd()
        self.report = {
            'timestamp': datetime.now().isoformat(),
            'repository': str(self.repo_path),
            'status': {}
        }
    
    def _run_git_command(self, cmd: list) -> str:
        """Git ëª…ë ¹ì–´ ì‹¤í–‰"""
        try:
            result = subprocess.run(
                ['git'] + cmd,
                capture_output=True,
                text=True,
                check=True,
                cwd=self.repo_path
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError:
            return ""
    
    def check_repository_size(self):
        """ì €ì¥ì†Œ í¬ê¸° í™•ì¸"""
        git_dir = self.repo_path / '.git'
        if git_dir.exists():
            total_size = sum(f.stat().st_size for f in git_dir.rglob('*') if f.is_file())
            size_mb = total_size / (1024 * 1024)
            
            self.report['status']['repository_size'] = {
                'size_mb': round(size_mb, 2),
                'status': 'healthy' if size_mb < 500 else 'warning' if size_mb < 1000 else 'critical'
            }
    
    def check_branch_status(self):
        """ë¸Œëœì¹˜ ìƒíƒœ í™•ì¸"""
        current_branch = self._run_git_command(['branch', '--show-current'])
        all_branches = self._run_git_command(['branch', '-a']).split('\n')
        
        local_branches = [b.strip().replace('* ', '') for b in all_branches if not b.strip().startswith('remotes/')]
        remote_branches = [b.strip() for b in all_branches if b.strip().startswith('remotes/')]
        
        self.report['status']['branches'] = {
            'current': current_branch,
            'local_count': len([b for b in local_branches if b]),
            'remote_count': len([b for b in remote_branches if b]),
            'status': 'healthy'
        }
    
    def check_uncommitted_changes(self):
        """ì»¤ë°‹ë˜ì§€ ì•Šì€ ë³€ê²½ì‚¬í•­ í™•ì¸"""
        status_output = self._run_git_command(['status', '--porcelain'])
        uncommitted_files = [line for line in status_output.split('\n') if line.strip()]
        
        self.report['status']['uncommitted_changes'] = {
            'count': len(uncommitted_files),
            'files': uncommitted_files[:10],  # ìµœëŒ€ 10ê°œë§Œ ê¸°ë¡
            'status': 'clean' if len(uncommitted_files) == 0 else 'dirty'
        }
    
    def check_remote_status(self):
        """ì›ê²© ì €ì¥ì†Œ ìƒíƒœ í™•ì¸"""
        try:
            # ì›ê²© ì €ì¥ì†Œ ì •ë³´
            remotes = self._run_git_command(['remote', '-v'])
            remote_lines = [line for line in remotes.split('\n') if line.strip()]
            
            # fetch ìƒíƒœ í™•ì¸
            fetch_result = subprocess.run(
                ['git', 'fetch', '--dry-run'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            self.report['status']['remote'] = {
                'configured': len(remote_lines) > 0,
                'accessible': fetch_result.returncode == 0,
                'remotes': remote_lines,
                'status': 'healthy' if len(remote_lines) > 0 else 'warning'
            }
        except subprocess.TimeoutExpired:
            self.report['status']['remote'] = {
                'configured': True,
                'accessible': False,
                'status': 'error',
                'error': 'timeout'
            }
    
    def check_large_files(self):
        """ëŒ€ìš©ëŸ‰ íŒŒì¼ í™•ì¸"""
        large_files = []
        for root, dirs, files in os.walk(self.repo_path):
            if '.git' in dirs:
                dirs.remove('.git')
            
            for file in files:
                file_path = Path(root) / file
                try:
                    size_mb = file_path.stat().st_size / (1024 * 1024)
                    if size_mb > 10:  # 10MB ì´ìƒ
                        large_files.append({
                            'path': str(file_path.relative_to(self.repo_path)),
                            'size_mb': round(size_mb, 2)
                        })
                except (OSError, PermissionError):
                    continue
        
        self.report['status']['large_files'] = {
            'count': len(large_files),
            'files': sorted(large_files, key=lambda x: x['size_mb'], reverse=True)[:5],
            'status': 'healthy' if len(large_files) == 0 else 'warning'
        }
    
    def generate_report(self):
        """ì¢…í•© ê±´ê°• ìƒíƒœ ë¦¬í¬íŠ¸ ìƒì„±"""
        print("ğŸ¥ Git ì €ì¥ì†Œ ê±´ê°• ìƒíƒœ ê²€ì‚¬ ì‹œì‘...")
        
        self.check_repository_size()
        self.check_branch_status()
        self.check_uncommitted_changes()
        self.check_remote_status()
        self.check_large_files()
        
        # ì „ì²´ ìƒíƒœ í‰ê°€
        statuses = [
            self.report['status']['repository_size']['status'],
            self.report['status']['branches']['status'],
            self.report['status']['uncommitted_changes']['status'],
            self.report['status']['remote']['status'],
            self.report['status']['large_files']['status']
        ]
        
        if 'critical' in statuses:
            overall_status = 'critical'
        elif 'error' in statuses or 'warning' in statuses:
            overall_status = 'warning'
        elif 'dirty' in statuses:
            overall_status = 'needs_attention'
        else:
            overall_status = 'healthy'
        
        self.report['overall_status'] = overall_status
        
        return self.report
    
    def print_report(self):
        """ë¦¬í¬íŠ¸ ì¶œë ¥"""
        report = self.generate_report()
        
        # ì „ì²´ ìƒíƒœ
        status_icon = {
            'healthy': 'âœ…',
            'needs_attention': 'âš ï¸',
            'warning': 'ğŸŸ¡',
            'critical': 'ğŸ”´',
            'error': 'âŒ'
        }
        
        print(f"\n{status_icon.get(report['overall_status'], 'â“')} ì „ì²´ ìƒíƒœ: {report['overall_status']}")
        
        # ì„¸ë¶€ í•­ëª©ë“¤
        print(f"\nğŸ“Š ì„¸ë¶€ ê²€ì‚¬ ê²°ê³¼:")
        
        # ì €ì¥ì†Œ í¬ê¸°
        size_info = report['status']['repository_size']
        print(f"  ğŸ“ ì €ì¥ì†Œ í¬ê¸°: {size_info['size_mb']}MB ({size_info['status']})")
        
        # ë¸Œëœì¹˜ ìƒíƒœ
        branch_info = report['status']['branches']
        print(f"  ğŸŒ¿ ë¸Œëœì¹˜: {branch_info['local_count']}ê°œ ë¡œì»¬, {branch_info['remote_count']}ê°œ ì›ê²©")
        print(f"      í˜„ì¬: {branch_info['current']}")
        
        # ë³€ê²½ì‚¬í•­
        changes_info = report['status']['uncommitted_changes']
        if changes_info['count'] > 0:
            print(f"  ğŸ“ ë¯¸ì»¤ë°‹ íŒŒì¼: {changes_info['count']}ê°œ")
        else:
            print(f"  ğŸ“ ì‘ì—… ë””ë ‰í„°ë¦¬: ê¹¨ë—í•¨")
        
        # ì›ê²© ì €ì¥ì†Œ
        remote_info = report['status']['remote']
        if remote_info['configured']:
            status_text = "ì—°ê²°ë¨" if remote_info['accessible'] else "ì—°ê²° ì‹¤íŒ¨"
            print(f"  ğŸ”— ì›ê²© ì €ì¥ì†Œ: {status_text}")
        else:
            print(f"  ğŸ”— ì›ê²© ì €ì¥ì†Œ: ì„¤ì •ë˜ì§€ ì•ŠìŒ")
        
        # ëŒ€ìš©ëŸ‰ íŒŒì¼
        large_files_info = report['status']['large_files']
        if large_files_info['count'] > 0:
            print(f"  ğŸ“¦ ëŒ€ìš©ëŸ‰ íŒŒì¼: {large_files_info['count']}ê°œ (LFS ê³ ë ¤)")
        else:
            print(f"  ğŸ“¦ ëŒ€ìš©ëŸ‰ íŒŒì¼: ì—†ìŒ")
        
        print(f"\nğŸ“… ê²€ì‚¬ ì‹œê°„: {report['timestamp']}")
        
        # ê¶Œì¥ì‚¬í•­
        if report['overall_status'] != 'healthy':
            print(f"\nğŸ’¡ ê¶Œì¥ì‚¬í•­:")
            
            if size_info['status'] in ['warning', 'critical']:
                print(f"  - ì €ì¥ì†Œ í¬ê¸°ê°€ í½ë‹ˆë‹¤. git gc ì‹¤í–‰ì„ ê³ ë ¤í•˜ì„¸ìš”.")
            
            if changes_info['count'] > 10:
                print(f"  - ë¯¸ì»¤ë°‹ íŒŒì¼ì´ ë§ìŠµë‹ˆë‹¤. ì •ë¦¬ë¥¼ ê³ ë ¤í•˜ì„¸ìš”.")
            
            if not remote_info['accessible']:
                print(f"  - ì›ê²© ì €ì¥ì†Œ ì—°ê²°ì„ í™•ì¸í•˜ì„¸ìš”.")
            
            if large_files_info['count'] > 0:
                print(f"  - ëŒ€ìš©ëŸ‰ íŒŒì¼ì„ Git LFSë¡œ ê´€ë¦¬í•˜ëŠ” ê²ƒì„ ê³ ë ¤í•˜ì„¸ìš”.")

def main():
    monitor = GitHealthMonitor()
    monitor.print_report()

if __name__ == "__main__":
    main()
EOF

chmod +x scripts/git_health_monitor.py

echo "ğŸ¥ Git ê±´ê°• ìƒíƒœ ëª¨ë‹ˆí„°ë§ ìŠ¤í¬ë¦½íŠ¸ ìƒì„± ì™„ë£Œ"
```

---

## ğŸ¯ 6. ì™„ë£Œ í™•ì¸ ë° í…ŒìŠ¤íŠ¸

### 6.1 ì „ì²´ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸

```bash
# ê³ ê¸‰ Git ì›Œí¬í”Œë¡œìš° ì¢…í•© í…ŒìŠ¤íŠ¸
echo "ğŸ§ª ê³ ê¸‰ Git ì›Œí¬í”Œë¡œìš° í…ŒìŠ¤íŠ¸ ì‹œì‘..."

# 1. Pre-commit í…ŒìŠ¤íŠ¸
echo "1. Pre-commit hooks í…ŒìŠ¤íŠ¸..."
if command -v pre-commit &> /dev/null; then
    pre-commit run --all-files || echo "âš ï¸  Pre-commit ê²€ì‚¬ì—ì„œ ì¼ë¶€ ì´ìŠˆ ë°œê²¬"
else
    echo "âš ï¸  Pre-commitì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
fi

# 2. ë¸Œëœì¹˜ ê´€ë¦¬ ìŠ¤í¬ë¦½íŠ¸ í…ŒìŠ¤íŠ¸
echo ""
echo "2. ë¸Œëœì¹˜ ê´€ë¦¬ ìŠ¤í¬ë¦½íŠ¸ í…ŒìŠ¤íŠ¸..."
python scripts/git_branch_manager.py status

# 3. LFS ìƒíƒœ í™•ì¸
echo ""
echo "3. Git LFS ìƒíƒœ í™•ì¸..."
python scripts/git_lfs_manager.py status

# 4. ì €ì¥ì†Œ ê±´ê°• ìƒíƒœ í™•ì¸
echo ""
echo "4. ì €ì¥ì†Œ ê±´ê°• ìƒíƒœ í™•ì¸..."
python scripts/git_health_monitor.py

# 5. ì›Œí¬í”Œë¡œìš° ìŠ¤í¬ë¦½íŠ¸ í…ŒìŠ¤íŠ¸
echo ""
echo "5. ì›Œí¬í”Œë¡œìš° ìë™í™” ìŠ¤í¬ë¦½íŠ¸ í…ŒìŠ¤íŠ¸..."
python scripts/git_workflow_automation.py --help > /dev/null && echo "âœ… ì›Œí¬í”Œë¡œìš° ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ê°€ëŠ¥"

echo ""
echo "âœ… ëª¨ë“  í…ŒìŠ¤íŠ¸ ì™„ë£Œ!"
```

### 6.2 ì„¤ì • ë° ìŠ¤í¬ë¦½íŠ¸ ì»¤ë°‹

```bash
# ëª¨ë“  ë³€ê²½ì‚¬í•­ì„ Gitì— ì¶”ê°€ ë° ì»¤ë°‹
echo "ğŸ’¾ ê³ ê¸‰ Git ì›Œí¬í”Œë¡œìš° ì„¤ì •ì„ ì»¤ë°‹í•©ë‹ˆë‹¤..."

# ë³€ê²½ëœ íŒŒì¼ë“¤ ìŠ¤í…Œì´ì§•
git add .pre-commit-config.yaml
git add scripts/hooks/
git add scripts/git_branch_manager.py
git add scripts/git_lfs_manager.py
git add scripts/git_workflow_automation.py
git add scripts/git_health_monitor.py
git add .gitattributes

# ì»¤ë°‹
git commit -m "feat(stage3): implement advanced Git workflows

- Add comprehensive pre-commit configuration
- Create custom Git hooks for data and config validation
- Implement advanced branch management automation
- Set up Git LFS for large file handling
- Add Git workflow automation scripts
- Create repository health monitoring system
- Configure Git performance optimizations

Features:
- Pre-commit hooks with MLOps-specific validations
- Automated branch creation and cleanup
- LFS management for large data/model files
- Comprehensive repository health monitoring
- Performance-optimized Git configuration"

echo "âœ… 3.8 ê³ ê¸‰ Git ì›Œí¬í”Œë¡œìš° êµ¬í˜„ ì™„ë£Œ!"
echo "ğŸ”„ ë‹¤ìŒ ë‹¨ê³„: 4ë‹¨ê³„ CI/CD íŒŒì´í”„ë¼ì¸ êµ¬ì¶•"
```

---

## âœ… ì™„ë£Œ ê¸°ì¤€

### ê¸°ëŠ¥ì  ì™„ë£Œ ê¸°ì¤€
- [ ] Pre-commit hooks ì„¤ì • ë° ì»¤ìŠ¤í…€ ê²€ì¦ êµ¬í˜„
- [ ] ìë™í™”ëœ ë¸Œëœì¹˜ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¶•
- [ ] Git LFSë¥¼ í†µí•œ ëŒ€ìš©ëŸ‰ íŒŒì¼ ê´€ë¦¬
- [ ] MLOps ì›Œí¬í”Œë¡œìš° ìë™í™” ë„êµ¬ ê°œë°œ
- [ ] ì €ì¥ì†Œ ê±´ê°• ìƒíƒœ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

### ê¸°ìˆ ì  ì™„ë£Œ ê¸°ì¤€
- [ ] ëª¨ë“  ìŠ¤í¬ë¦½íŠ¸ê°€ ì‹¤í–‰ ê°€ëŠ¥í•˜ê³  ì˜¤ë¥˜ ì—†ì´ ì‘ë™
- [ ] Git ì„±ëŠ¥ ìµœì í™” ì„¤ì • ì ìš©
- [ ] Docker í™˜ê²½ì—ì„œë„ ì •ìƒ ì‘ë™
- [ ] ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¶•
- [ ] ì¢…í•©ì ì¸ í’ˆì§ˆ ê²€ì¦ ì‹œìŠ¤í…œ êµ¬í˜„

### í”„ë¡œì„¸ìŠ¤ ì™„ë£Œ ê¸°ì¤€
- [ ] íŒ€ ì›Œí¬í”Œë¡œìš° í‘œì¤€í™” ë° ìë™í™”
- [ ] íš¨ìœ¨ì ì¸ ë¸Œëœì¹˜ ê´€ë¦¬ ì²´ê³„ êµ¬ì¶•
- [ ] ì½”ë“œ í’ˆì§ˆ ìë™ ê²€ì¦ ì‹œìŠ¤í…œ
- [ ] ì €ì¥ì†Œ ìœ ì§€ë³´ìˆ˜ ìë™í™”
- [ ] MLOps ê°œë°œ í”„ë¡œì„¸ìŠ¤ ìµœì í™”

---

## ğŸ“Š êµ¬í˜„ ê²°ê³¼

### ì£¼ìš” êµ¬í˜„ ì‚¬í•­:
1. âœ… Pre-commit hooks ë° ì»¤ìŠ¤í…€ ê²€ì¦ ì‹œìŠ¤í…œ
2. âœ… ê³ ê¸‰ ë¸Œëœì¹˜ ê´€ë¦¬ ìë™í™” ë„êµ¬
3. âœ… Git LFSë¥¼ í†µí•œ ëŒ€ìš©ëŸ‰ íŒŒì¼ ê´€ë¦¬
4. âœ… MLOps ì›Œí¬í”Œë¡œìš° ìë™í™” ìŠ¤í¬ë¦½íŠ¸
5. âœ… ì €ì¥ì†Œ ê±´ê°• ìƒíƒœ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
6. âœ… Git ì„±ëŠ¥ ìµœì í™” ì„¤ì •

### ìƒì„±ëœ íŒŒì¼ë“¤:
- `.pre-commit-config.yaml` - Pre-commit ì„¤ì •
- `scripts/hooks/` - ì»¤ìŠ¤í…€ Git Hook ìŠ¤í¬ë¦½íŠ¸ë“¤
- `scripts/git_branch_manager.py` - ë¸Œëœì¹˜ ê´€ë¦¬ ìë™í™”
- `scripts/git_lfs_manager.py` - Git LFS ê´€ë¦¬ ë„êµ¬
- `scripts/git_workflow_automation.py` - ì›Œí¬í”Œë¡œìš° ìë™í™”
- `scripts/git_health_monitor.py` - ì €ì¥ì†Œ ê±´ê°• ìƒíƒœ ëª¨ë‹ˆí„°ë§
- `.gitattributes` - Git LFS ì¶”ì  ì„¤ì •

ì´ì œ 3ë‹¨ê³„ ë²„ì „ ê´€ë¦¬ ì‹œìŠ¤í…œì´ ì™„ì „íˆ êµ¬ì¶•ë˜ì—ˆìœ¼ë©°, ë‹¤ìŒ ë‹¨ê³„ì¸ 4ë‹¨ê³„ CI/CD íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ ì§„í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
