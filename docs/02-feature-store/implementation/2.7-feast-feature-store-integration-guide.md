---
title: "2.7 Feast í”¼ì²˜ ìŠ¤í† ì–´ í†µí•© ê°€ì´ë“œ"
description: "ì˜¤í”ˆì†ŒìŠ¤ Feastë¥¼ í™œìš©í•œ ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ í”¼ì²˜ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¶•"
author: "MLOps Team"
created: "2025-06-05"
updated: "2025-06-05"
version: "1.0"
stage: "2.7"
category: "Enterprise Feature Store"
tags: ["Feast", "ì—”í„°í”„ë¼ì´ì¦ˆ", "ì‹¤ì‹œê°„ì„œë¹™", "ì˜¨ë¼ì¸ìŠ¤í† ì–´", "ì˜¤í”„ë¼ì¸ìŠ¤í† ì–´"]
prerequisites: ["2.6 ë²„ì „ ê´€ë¦¬ ì™„ë£Œ", "Redis", "PostgreSQL", "Kubernetes"]
difficulty: "advanced"
estimated_time: "8-10ì‹œê°„"
---

# 2.7 Feast í”¼ì²˜ ìŠ¤í† ì–´ í†µí•© ê°€ì´ë“œ

## ğŸ“‹ ê°œìš”

**ëª©í‘œ**: ì˜¤í”ˆì†ŒìŠ¤ Feastë¥¼ í™œìš©í•œ ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ í”¼ì²˜ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¶•

**í•µì‹¬ ê°€ì¹˜**: í™•ì¥ ê°€ëŠ¥í•˜ê³  ì‹¤ì‹œê°„ ì„œë¹™ì´ ê°€ëŠ¥í•œ í”„ë¡œë•ì…˜ê¸‰ í”¼ì²˜ ìŠ¤í† ì–´ êµ¬í˜„

---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

### ì´ë¡ ì  ëª©í‘œ
- Feast ì•„í‚¤í…ì²˜ì™€ í•µì‹¬ ê°œë… ì´í•´
- ì˜¨ë¼ì¸/ì˜¤í”„ë¼ì¸ ìŠ¤í† ì–´ì˜ ì—­í• ê³¼ ì°¨ì´ì  í•™ìŠµ
- ì‹¤ì‹œê°„ í”¼ì²˜ ì„œë¹™ íŒ¨í„´ ìŠµë“

### ì‹¤ë¬´ì  ëª©í‘œ
- Feast ì„¤ì¹˜ ë° ê¸°ë³¸ ì„¤ì •
- ì˜í™” ì¶”ì²œ ë„ë©”ì¸ì— ë§ëŠ” í”¼ì²˜ ì •ì˜
- ì‹¤ì‹œê°„ ì„œë¹™ í™˜ê²½ êµ¬ì¶• ë° ìµœì í™”

---

## ğŸ”§ 2.7.1 Feast ì„¤ì¹˜ ë° ê¸°ë³¸ ì„¤ì •

### í™˜ê²½ êµ¬ì„±

```yaml
# docker-compose.feast.yml
version: '3.8'

services:
  # Feast Core Services
  feast-registry:
    image: postgres:14
    environment:
      POSTGRES_DB: feast_registry
      POSTGRES_USER: feast
      POSTGRES_PASSWORD: feast_password
    ports:
      - "5433:5432"
    volumes:
      - feast_registry_data:/var/lib/postgresql/data

  # Online Store (Redis)
  feast-online-store:
    image: redis:7-alpine
    ports:
      - "6380:6379"
    volumes:
      - feast_redis_data:/data

  # Offline Store (PostgreSQL)
  feast-offline-store:
    image: postgres:14
    environment:
      POSTGRES_DB: feast_offline
      POSTGRES_USER: feast
      POSTGRES_PASSWORD: feast_password
    ports:
      - "5434:5432"
    volumes:
      - feast_offline_data:/var/lib/postgresql/data

volumes:
  feast_registry_data:
  feast_redis_data:
  feast_offline_data:
```

### Feast ì„¤ì • íŒŒì¼

```yaml
# feature_store.yaml
project: movie_recommendation
registry: postgresql://feast:feast_password@localhost:5433/feast_registry
provider: local

online_store:
  type: redis
  connection_string: "localhost:6380"

offline_store:
  type: postgres
  host: localhost
  port: 5434
  database: feast_offline
  user: feast
  password: feast_password

entity_key_serialization_version: 2
```

### Feast í´ë¼ì´ì–¸íŠ¸ ì„¤ì •

```python
import pandas as pd
from feast import FeatureStore, Entity, FeatureView, Field
from feast.types import Float32, Int64, String, UnixTimestamp
from datetime import datetime, timedelta
import logging

class MovieRecommendationFeatureStore:
    """ì˜í™” ì¶”ì²œì„ ìœ„í•œ Feast í”¼ì²˜ ìŠ¤í† ì–´"""
    
    def __init__(self, repo_path: str = "."):
        self.fs = FeatureStore(repo_path=repo_path)
        self.logger = logging.getLogger(__name__)
        
        # ì—”í‹°í‹° ì •ì˜
        self.entities = self._define_entities()
        
        # í”¼ì²˜ ë·° ì •ì˜
        self.feature_views = self._define_feature_views()
        
    def _define_entities(self) -> dict:
        """ë„ë©”ì¸ ì—”í‹°í‹° ì •ì˜"""
        
        # ì‚¬ìš©ì ì—”í‹°í‹°
        user_entity = Entity(
            name="user_id",
            description="ì‚¬ìš©ì ê³ ìœ  ì‹ë³„ì",
            value_type=Int64
        )
        
        # ì˜í™” ì—”í‹°í‹°
        movie_entity = Entity(
            name="movie_id", 
            description="ì˜í™” ê³ ìœ  ì‹ë³„ì",
            value_type=Int64
        )
        
        return {
            'user': user_entity,
            'movie': movie_entity
        }
    
    def _define_feature_views(self) -> dict:
        """í”¼ì²˜ ë·° ì •ì˜"""
        
        # ì‚¬ìš©ì í”„ë¡œí•„ í”¼ì²˜
        user_profile_fv = FeatureView(
            name="user_profile_features",
            entities=[self.entities['user']],
            ttl=timedelta(days=7),
            schema=[
                Field(name="age", dtype=Int64),
                Field(name="avg_rating", dtype=Float32),
                Field(name="total_movies_watched", dtype=Int64),
                Field(name="favorite_genre", dtype=String),
                Field(name="account_created_days", dtype=Int64),
            ],
            source=None  # ë‚˜ì¤‘ì— ì„¤ì •
        )
        
        # ì˜í™” ë©”íƒ€ë°ì´í„° í”¼ì²˜
        movie_metadata_fv = FeatureView(
            name="movie_metadata_features",
            entities=[self.entities['movie']],
            ttl=timedelta(days=30),
            schema=[
                Field(name="vote_average", dtype=Float32),
                Field(name="vote_count", dtype=Int64),
                Field(name="popularity", dtype=Float32),
                Field(name="runtime", dtype=Int64),
                Field(name="release_year", dtype=Int64),
                Field(name="genre_action", dtype=Int64),
                Field(name="genre_comedy", dtype=Int64),
                Field(name="genre_drama", dtype=Int64),
                Field(name="genre_horror", dtype=Int64),
                Field(name="genre_romance", dtype=Int64),
            ],
            source=None
        )
        
        # ì‚¬ìš©ì-ì˜í™” ìƒí˜¸ì‘ìš© í”¼ì²˜
        user_movie_interaction_fv = FeatureView(
            name="user_movie_interaction_features",
            entities=[self.entities['user'], self.entities['movie']],
            ttl=timedelta(days=1),
            schema=[
                Field(name="watch_time_minutes", dtype=Float32),
                Field(name="completion_rate", dtype=Float32),
                Field(name="user_rating", dtype=Float32),
                Field(name="watch_count", dtype=Int64),
                Field(name="last_watched_days_ago", dtype=Int64),
            ],
            source=None
        )
        
        return {
            'user_profile': user_profile_fv,
            'movie_metadata': movie_metadata_fv,
            'user_movie_interaction': user_movie_interaction_fv
        }
    
    def setup_feature_store(self):
        """í”¼ì²˜ ìŠ¤í† ì–´ ì´ˆê¸° ì„¤ì •"""
        
        try:
            # ì—”í‹°í‹° ë“±ë¡
            for entity in self.entities.values():
                self.fs.apply([entity])
                self.logger.info(f"ì—”í‹°í‹° ë“±ë¡: {entity.name}")
            
            # í”¼ì²˜ ë·° ë“±ë¡ (ì†ŒìŠ¤ ì„¤ì • í›„)
            # ì´ëŠ” ë°ì´í„° ì†ŒìŠ¤ê°€ ì¤€ë¹„ëœ í›„ì— ì‹¤í–‰ë©ë‹ˆë‹¤
            
            self.logger.info("âœ… Feast í”¼ì²˜ ìŠ¤í† ì–´ ì„¤ì • ì™„ë£Œ")
            
        except Exception as e:
            self.logger.error(f"âŒ í”¼ì²˜ ìŠ¤í† ì–´ ì„¤ì • ì‹¤íŒ¨: {e}")
            raise
```

---

## ğŸ”§ 2.7.2 ë°ì´í„° ì†ŒìŠ¤ í†µí•©

### ê¸°ì¡´ í”¼ì²˜ ë°ì´í„°ë¥¼ Feast í˜•ì‹ìœ¼ë¡œ ë³€í™˜

```python
from feast.data_source import PushSource
from feast.infra.offline_stores.file_source import FileSource
import pyarrow.parquet as pq

class FeastDataAdapter:
    """ê¸°ì¡´ í”¼ì²˜ ë°ì´í„°ë¥¼ Feast í˜•ì‹ìœ¼ë¡œ ë³€í™˜"""
    
    def __init__(self, feature_store: MovieRecommendationFeatureStore):
        self.feature_store = feature_store
        
    def convert_tmdb_features_to_feast(self, 
                                     input_data_path: str,
                                     output_data_path: str) -> dict:
        """TMDB í”¼ì²˜ ë°ì´í„°ë¥¼ Feast í˜•ì‹ìœ¼ë¡œ ë³€í™˜"""
        
        # ê¸°ì¡´ í”¼ì²˜ ë°ì´í„° ë¡œë“œ
        df = pd.read_parquet(input_data_path)
        
        # Feast í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        feast_data = self._transform_to_feast_format(df)
        
        # í”¼ì²˜ ë·°ë³„ë¡œ ë°ì´í„° ë¶„í•  ë° ì €ì¥
        converted_files = {}
        
        for feature_view_name, data in feast_data.items():
            output_file = f"{output_data_path}/{feature_view_name}.parquet"
            data.to_parquet(output_file, index=False)
            converted_files[feature_view_name] = output_file
            
        return converted_files
    
    def _transform_to_feast_format(self, df: pd.DataFrame) -> dict:
        """ë°ì´í„°ë¥¼ Feast í”¼ì²˜ ë·° í˜•ì‹ìœ¼ë¡œ ë³€í™˜"""
        
        feast_data = {}
        
        # ì‚¬ìš©ì í”„ë¡œí•„ í”¼ì²˜ ë³€í™˜
        if self._has_user_features(df):
            user_features = self._extract_user_profile_features(df)
            feast_data['user_profile_features'] = user_features
        
        # ì˜í™” ë©”íƒ€ë°ì´í„° í”¼ì²˜ ë³€í™˜
        if self._has_movie_features(df):
            movie_features = self._extract_movie_metadata_features(df)
            feast_data['movie_metadata_features'] = movie_features
        
        # ìƒí˜¸ì‘ìš© í”¼ì²˜ ë³€í™˜
        if self._has_interaction_features(df):
            interaction_features = self._extract_interaction_features(df)
            feast_data['user_movie_interaction_features'] = interaction_features
        
        return feast_data
    
    def _extract_user_profile_features(self, df: pd.DataFrame) -> pd.DataFrame:
        """ì‚¬ìš©ì í”„ë¡œí•„ í”¼ì²˜ ì¶”ì¶œ"""
        
        # ì‚¬ìš©ìë³„ ì§‘ê³„
        user_agg = df.groupby('user_id').agg({
            'rating': ['mean', 'count'],
            'watch_seconds': 'sum'
        }).reset_index()
        
        # ì»¬ëŸ¼ ì´ë¦„ í‰ë©´í™”
        user_agg.columns = ['user_id', 'avg_rating', 'total_movies_watched', 'total_watch_time']
        
        # Feast ìŠ¤í‚¤ë§ˆì— ë§ëŠ” í”¼ì²˜ ìƒì„±
        user_features = pd.DataFrame({
            'user_id': user_agg['user_id'],
            'age': 25,  # ì‹œë®¬ë ˆì´ì…˜ ë°ì´í„°
            'avg_rating': user_agg['avg_rating'].round(2),
            'total_movies_watched': user_agg['total_movies_watched'],
            'favorite_genre': 'Action',  # ì‹œë®¬ë ˆì´ì…˜ ë°ì´í„°
            'account_created_days': 365,  # ì‹œë®¬ë ˆì´ì…˜ ë°ì´í„°
            'event_timestamp': datetime.now()  # í•„ìˆ˜ í•„ë“œ
        })
        
        return user_features
    
    def _extract_movie_metadata_features(self, df: pd.DataFrame) -> pd.DataFrame:
        """ì˜í™” ë©”íƒ€ë°ì´í„° í”¼ì²˜ ì¶”ì¶œ"""
        
        # ì˜í™”ë³„ ê³ ìœ  ì •ë³´ (ì‹œë®¬ë ˆì´ì…˜)
        unique_movies = df['content_id'].unique()
        
        movie_features = pd.DataFrame({
            'movie_id': unique_movies,
            'vote_average': np.random.uniform(4.0, 9.0, len(unique_movies)),
            'vote_count': np.random.randint(100, 10000, len(unique_movies)),
            'popularity': np.random.uniform(10.0, 500.0, len(unique_movies)),
            'runtime': np.random.randint(80, 180, len(unique_movies)),
            'release_year': np.random.randint(1990, 2024, len(unique_movies)),
            'genre_action': np.random.randint(0, 2, len(unique_movies)),
            'genre_comedy': np.random.randint(0, 2, len(unique_movies)),
            'genre_drama': np.random.randint(0, 2, len(unique_movies)),
            'genre_horror': np.random.randint(0, 2, len(unique_movies)),
            'genre_romance': np.random.randint(0, 2, len(unique_movies)),
            'event_timestamp': datetime.now()
        })
        
        return movie_features
    
    def _extract_interaction_features(self, df: pd.DataFrame) -> pd.DataFrame:
        """ìƒí˜¸ì‘ìš© í”¼ì²˜ ì¶”ì¶œ"""
        
        interaction_features = pd.DataFrame({
            'user_id': df['user_id'],
            'movie_id': df['content_id'],
            'watch_time_minutes': df['watch_seconds'] / 60,
            'completion_rate': np.minimum(df['watch_seconds'] / 7200, 1.0),  # 2ì‹œê°„ ê¸°ì¤€
            'user_rating': df['rating'],
            'watch_count': 1,  # ì‹œë®¬ë ˆì´ì…˜
            'last_watched_days_ago': 0,  # ì‹œë®¬ë ˆì´ì…˜
            'event_timestamp': datetime.now()
        })
        
        return interaction_features
    
    def _has_user_features(self, df: pd.DataFrame) -> bool:
        return 'user_id' in df.columns
    
    def _has_movie_features(self, df: pd.DataFrame) -> bool:
        return 'content_id' in df.columns
    
    def _has_interaction_features(self, df: pd.DataFrame) -> bool:
        return all(col in df.columns for col in ['user_id', 'content_id', 'rating'])
```

### í”¼ì²˜ ë·° ë°ì´í„° ì†ŒìŠ¤ ì„¤ì •

```python
def setup_feature_views_with_sources(feature_store: MovieRecommendationFeatureStore,
                                    data_path: str):
    """ë°ì´í„° ì†ŒìŠ¤ì™€ í•¨ê»˜ í”¼ì²˜ ë·° ì„¤ì •"""
    
    # íŒŒì¼ ì†ŒìŠ¤ ì •ì˜
    user_profile_source = FileSource(
        name="user_profile_source",
        path=f"{data_path}/user_profile_features.parquet",
        timestamp_field="event_timestamp"
    )
    
    movie_metadata_source = FileSource(
        name="movie_metadata_source",
        path=f"{data_path}/movie_metadata_features.parquet",
        timestamp_field="event_timestamp"
    )
    
    interaction_source = FileSource(
        name="interaction_source",
        path=f"{data_path}/user_movie_interaction_features.parquet",
        timestamp_field="event_timestamp"
    )
    
    # í”¼ì²˜ ë·°ì— ì†ŒìŠ¤ ì—°ê²°
    feature_store.feature_views['user_profile'].source = user_profile_source
    feature_store.feature_views['movie_metadata'].source = movie_metadata_source
    feature_store.feature_views['user_movie_interaction'].source = interaction_source
    
    # Feastì— í”¼ì²˜ ë·° ë“±ë¡
    try:
        feature_store.fs.apply(list(feature_store.feature_views.values()))
        print("âœ… í”¼ì²˜ ë·° ë“±ë¡ ì™„ë£Œ")
    except Exception as e:
        print(f"âŒ í”¼ì²˜ ë·° ë“±ë¡ ì‹¤íŒ¨: {e}")
        raise
```

---

## ğŸ”§ 2.7.3 ì‹¤ì‹œê°„ ì„œë¹™ ì„¤ì •

### ì˜¨ë¼ì¸ ìŠ¤í† ì–´ êµ¬ì¶•

```python
from feast import FeatureService
from datetime import timedelta

class FeastServingManager:
    """Feast ì‹¤ì‹œê°„ ì„œë¹™ ê´€ë¦¬ì"""
    
    def __init__(self, feature_store: FeatureStore):
        self.fs = feature_store
        self.feature_services = {}
        
    def create_recommendation_feature_service(self):
        """ì˜í™” ì¶”ì²œì„ ìœ„í•œ í”¼ì²˜ ì„œë¹„ìŠ¤ ìƒì„±"""
        
        # ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜ìš© í”¼ì²˜ ì„œë¹„ìŠ¤
        recommendation_fs = FeatureService(
            name="movie_recommendation_service",
            features=[
                "user_profile_features:avg_rating",
                "user_profile_features:total_movies_watched",
                "user_profile_features:favorite_genre",
                "movie_metadata_features:vote_average",
                "movie_metadata_features:popularity",
                "movie_metadata_features:genre_action",
                "movie_metadata_features:genre_comedy",
                "movie_metadata_features:genre_drama",
                "movie_metadata_features:genre_horror",
                "movie_metadata_features:genre_romance",
            ],
            description="ì˜í™” ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜ìš© í”¼ì²˜ ì„¸íŠ¸"
        )
        
        self.feature_services['recommendation'] = recommendation_fs
        
        # Feastì— ë“±ë¡
        self.fs.apply([recommendation_fs])
        print("âœ… ì¶”ì²œ í”¼ì²˜ ì„œë¹„ìŠ¤ ë“±ë¡ ì™„ë£Œ")
    
    def materialize_features_to_online_store(self, 
                                           start_date: datetime,
                                           end_date: datetime):
        """í”¼ì²˜ë¥¼ ì˜¨ë¼ì¸ ìŠ¤í† ì–´ë¡œ ì‹¤ì²´í™”"""
        
        try:
            self.fs.materialize_incremental(end_date)
            print(f"âœ… í”¼ì²˜ ì‹¤ì²´í™” ì™„ë£Œ: {start_date} ~ {end_date}")
        except Exception as e:
            print(f"âŒ í”¼ì²˜ ì‹¤ì²´í™” ì‹¤íŒ¨: {e}")
            raise
    
    def get_online_features_for_recommendation(self, 
                                             user_ids: list,
                                             movie_ids: list) -> pd.DataFrame:
        """ì¶”ì²œì„ ìœ„í•œ ì˜¨ë¼ì¸ í”¼ì²˜ ì¡°íšŒ"""
        
        # ì—”í‹°í‹° ì •ì˜
        entity_rows = []
        for user_id in user_ids:
            for movie_id in movie_ids:
                entity_rows.append({
                    "user_id": user_id,
                    "movie_id": movie_id
                })
        
        # ì˜¨ë¼ì¸ í”¼ì²˜ ì¡°íšŒ
        try:
            feature_vector = self.fs.get_online_features(
                features=self.feature_services['recommendation'],
                entity_rows=entity_rows
            )
            
            return feature_vector.to_df()
            
        except Exception as e:
            print(f"âŒ ì˜¨ë¼ì¸ í”¼ì²˜ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            raise
    
    def batch_get_features_for_training(self,
                                      entity_df: pd.DataFrame) -> pd.DataFrame:
        """ëª¨ë¸ í›ˆë ¨ì„ ìœ„í•œ ë°°ì¹˜ í”¼ì²˜ ì¡°íšŒ"""
        
        try:
            training_df = self.fs.get_historical_features(
                entity_df=entity_df,
                features=self.feature_services['recommendation']
            ).to_df()
            
            return training_df
            
        except Exception as e:
            print(f"âŒ ë°°ì¹˜ í”¼ì²˜ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            raise

class RealtimeFeatureAPI:
    """ì‹¤ì‹œê°„ í”¼ì²˜ API"""
    
    def __init__(self, serving_manager: FeastServingManager):
        self.serving_manager = serving_manager
        
    async def get_user_features(self, user_id: int) -> dict:
        """ì‚¬ìš©ì í”¼ì²˜ ì¡°íšŒ"""
        
        entity_rows = [{"user_id": user_id}]
        
        features = self.serving_manager.fs.get_online_features(
            features=[
                "user_profile_features:avg_rating",
                "user_profile_features:total_movies_watched", 
                "user_profile_features:favorite_genre"
            ],
            entity_rows=entity_rows
        )
        
        feature_dict = features.to_dict()
        
        return {
            "user_id": user_id,
            "avg_rating": feature_dict["avg_rating"][0],
            "total_movies_watched": feature_dict["total_movies_watched"][0],
            "favorite_genre": feature_dict["favorite_genre"][0]
        }
    
    async def get_movie_features(self, movie_id: int) -> dict:
        """ì˜í™” í”¼ì²˜ ì¡°íšŒ"""
        
        entity_rows = [{"movie_id": movie_id}]
        
        features = self.serving_manager.fs.get_online_features(
            features=[
                "movie_metadata_features:vote_average",
                "movie_metadata_features:popularity",
                "movie_metadata_features:genre_action",
                "movie_metadata_features:genre_comedy",
                "movie_metadata_features:genre_drama"
            ],
            entity_rows=entity_rows
        )
        
        feature_dict = features.to_dict()
        
        return {
            "movie_id": movie_id,
            "vote_average": feature_dict["vote_average"][0],
            "popularity": feature_dict["popularity"][0],
            "genres": {
                "action": bool(feature_dict["genre_action"][0]),
                "comedy": bool(feature_dict["genre_comedy"][0]),
                "drama": bool(feature_dict["genre_drama"][0])
            }
        }
    
    async def get_recommendation_features(self, user_id: int, 
                                        movie_ids: list) -> dict:
        """ì¶”ì²œì„ ìœ„í•œ í†µí•© í”¼ì²˜ ì¡°íšŒ"""
        
        feature_df = self.serving_manager.get_online_features_for_recommendation(
            user_ids=[user_id],
            movie_ids=movie_ids
        )
        
        # ì¶”ì²œ ìŠ¤ì½”ì–´ ê³„ì‚° (ê°„ë‹¨í•œ ì˜ˆì‹œ)
        recommendations = []
        
        for _, row in feature_df.iterrows():
            score = (
                row['vote_average'] * 0.3 +
                row['popularity'] / 100 * 0.2 +
                row['avg_rating'] * 0.5
            )
            
            recommendations.append({
                "movie_id": row['movie_id'],
                "recommendation_score": score,
                "features_used": {
                    "user_avg_rating": row['avg_rating'],
                    "movie_vote_average": row['vote_average'],
                    "movie_popularity": row['popularity']
                }
            })
        
        # ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬
        recommendations.sort(key=lambda x: x['recommendation_score'], reverse=True)
        
        return {
            "user_id": user_id,
            "recommendations": recommendations,
            "feature_retrieval_time_ms": "< 10ms"  # ì‹¤ì œë¡œëŠ” ì¸¡ì •
        }
```

---

## ğŸ”§ 2.7.4 ëª¨ë‹ˆí„°ë§ ë° ê´€ì¸¡ì„±

### Feast ë©”íŠ¸ë¦­ ìˆ˜ì§‘

```python
import time
from prometheus_client import Counter, Histogram, Gauge

class FeastMetricsCollector:
    """Feast ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°"""
    
    def __init__(self):
        # Prometheus ë©”íŠ¸ë¦­ ì •ì˜
        self.feature_requests = Counter(
            'feast_feature_requests_total',
            'Total number of feature requests',
            ['feature_service', 'entity_type']
        )
        
        self.feature_request_duration = Histogram(
            'feast_feature_request_duration_seconds',
            'Time spent on feature requests',
            ['feature_service', 'entity_type']
        )
        
        self.online_store_size = Gauge(
            'feast_online_store_size_bytes',
            'Size of online store in bytes'
        )
        
        self.feature_freshness = Histogram(
            'feast_feature_freshness_seconds',
            'Time since last feature update',
            ['feature_view']
        )
    
    def record_feature_request(self, feature_service: str, 
                             entity_type: str, duration: float):
        """í”¼ì²˜ ìš”ì²­ ë©”íŠ¸ë¦­ ê¸°ë¡"""
        
        self.feature_requests.labels(
            feature_service=feature_service,
            entity_type=entity_type
        ).inc()
        
        self.feature_request_duration.labels(
            feature_service=feature_service,
            entity_type=entity_type
        ).observe(duration)
    
    def update_online_store_size(self, size_bytes: int):
        """ì˜¨ë¼ì¸ ìŠ¤í† ì–´ í¬ê¸° ì—…ë°ì´íŠ¸"""
        self.online_store_size.set(size_bytes)
    
    def record_feature_freshness(self, feature_view: str, 
                                freshness_seconds: float):
        """í”¼ì²˜ ì‹ ì„ ë„ ê¸°ë¡"""
        self.feature_freshness.labels(feature_view=feature_view).observe(freshness_seconds)

class FeastHealthChecker:
    """Feast ì‹œìŠ¤í…œ ê±´ê°•ì„± ê²€ì‚¬"""
    
    def __init__(self, feature_store: FeatureStore):
        self.fs = feature_store
        
    async def check_online_store_health(self) -> dict:
        """ì˜¨ë¼ì¸ ìŠ¤í† ì–´ ê±´ê°•ì„± ê²€ì‚¬"""
        
        health_status = {
            "online_store": "unknown",
            "registry": "unknown",
            "feature_views": {},
            "last_check": datetime.now().isoformat()
        }
        
        try:
            # ê°„ë‹¨í•œ í”¼ì²˜ ì¡°íšŒë¡œ ì˜¨ë¼ì¸ ìŠ¤í† ì–´ í…ŒìŠ¤íŠ¸
            test_entity = [{"user_id": 1}]
            
            start_time = time.time()
            self.fs.get_online_features(
                features=["user_profile_features:avg_rating"],
                entity_rows=test_entity
            )
            response_time = time.time() - start_time
            
            health_status["online_store"] = "healthy"
            health_status["response_time_ms"] = response_time * 1000
            
        except Exception as e:
            health_status["online_store"] = "unhealthy"
            health_status["error"] = str(e)
        
        try:
            # ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì—°ê²° í…ŒìŠ¤íŠ¸
            feature_views = self.fs.list_feature_views()
            health_status["registry"] = "healthy"
            health_status["feature_view_count"] = len(feature_views)
            
        except Exception as e:
            health_status["registry"] = "unhealthy"
            health_status["registry_error"] = str(e)
        
        return health_status
    
    async def check_feature_freshness(self) -> dict:
        """í”¼ì²˜ ì‹ ì„ ë„ ê²€ì‚¬"""
        
        freshness_report = {}
        
        try:
            feature_views = self.fs.list_feature_views()
            
            for fv in feature_views:
                # ë§ˆì§€ë§‰ ì‹¤ì²´í™” ì‹œê°„ í™•ì¸ (êµ¬í˜„ í•„ìš”)
                last_materialization = self._get_last_materialization_time(fv.name)
                
                if last_materialization:
                    time_since_update = datetime.now() - last_materialization
                    freshness_report[fv.name] = {
                        "last_updated": last_materialization.isoformat(),
                        "minutes_since_update": time_since_update.total_seconds() / 60,
                        "status": "fresh" if time_since_update.total_seconds() < 3600 else "stale"
                    }
                else:
                    freshness_report[fv.name] = {
                        "status": "unknown",
                        "error": "Cannot determine last materialization time"
                    }
                    
        except Exception as e:
            freshness_report["error"] = str(e)
        
        return freshness_report
    
    def _get_last_materialization_time(self, feature_view_name: str) -> datetime:
        """ë§ˆì§€ë§‰ ì‹¤ì²´í™” ì‹œê°„ ì¡°íšŒ (êµ¬í˜„ í•„ìš”)"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” Feast ë©”íƒ€ë°ì´í„°ë‚˜ ë¡œê·¸ì—ì„œ ì¡°íšŒ
        return datetime.now() - timedelta(minutes=30)  # ì‹œë®¬ë ˆì´ì…˜
```

---

## ğŸ”§ 2.7.5 ì„±ëŠ¥ ìµœì í™” ë° í™•ì¥

### ìºì‹± ìµœì í™”

```python
class OptimizedFeastClient:
    """ìµœì í™”ëœ Feast í´ë¼ì´ì–¸íŠ¸"""
    
    def __init__(self, feature_store: FeatureStore):
        self.fs = feature_store
        self.local_cache = {}
        self.cache_ttl = 300  # 5ë¶„
        
    async def get_features_with_cache(self, entity_rows: list, 
                                    features: list) -> pd.DataFrame:
        """ìºì‹œë¥¼ í™œìš©í•œ í”¼ì²˜ ì¡°íšŒ"""
        
        # ìºì‹œ í‚¤ ìƒì„±
        cache_key = self._generate_cache_key(entity_rows, features)
        
        # ìºì‹œ í™•ì¸
        if cache_key in self.local_cache:
            cached_data, timestamp = self.local_cache[cache_key]
            
            if time.time() - timestamp < self.cache_ttl:
                return cached_data
        
        # ìºì‹œ ë¯¸ìŠ¤ - Feastì—ì„œ ì¡°íšŒ
        feature_vector = self.fs.get_online_features(
            features=features,
            entity_rows=entity_rows
        )
        
        result_df = feature_vector.to_df()
        
        # ìºì‹œì— ì €ì¥
        self.local_cache[cache_key] = (result_df, time.time())
        
        return result_df
    
    def _generate_cache_key(self, entity_rows: list, features: list) -> str:
        """ìºì‹œ í‚¤ ìƒì„±"""
        
        import hashlib
        import json
        
        cache_data = {
            'entity_rows': entity_rows,
            'features': sorted(features)
        }
        
        cache_str = json.dumps(cache_data, sort_keys=True)
        return hashlib.md5(cache_str.encode()).hexdigest()
    
    def invalidate_cache(self):
        """ìºì‹œ ë¬´íš¨í™”"""
        self.local_cache.clear()

class FeastBatchOptimizer:
    """Feast ë°°ì¹˜ ì²˜ë¦¬ ìµœì í™”"""
    
    def __init__(self, feature_store: FeatureStore):
        self.fs = feature_store
        
    def batch_materialize_features(self, batch_size: int = 1000):
        """ë°°ì¹˜ ë‹¨ìœ„ë¡œ í”¼ì²˜ ì‹¤ì²´í™”"""
        
        # ì‹¤ì²´í™”í•  í”¼ì²˜ ë·° ëª©ë¡
        feature_views = self.fs.list_feature_views()
        
        for fv in feature_views:
            try:
                print(f"ì‹¤ì²´í™” ì‹œì‘: {fv.name}")
                
                # ë°°ì¹˜ ë‹¨ìœ„ë¡œ ì‹¤ì²´í™” (ì‹¤ì œ êµ¬í˜„ì€ Feast ë²„ì „ì— ë”°ë¼ ë‹¤ë¦„)
                self.fs.materialize(
                    start_date=datetime.now() - timedelta(days=1),
                    end_date=datetime.now(),
                    feature_views=[fv]
                )
                
                print(f"âœ… ì‹¤ì²´í™” ì™„ë£Œ: {fv.name}")
                
            except Exception as e:
                print(f"âŒ ì‹¤ì²´í™” ì‹¤íŒ¨: {fv.name} - {e}")
                continue
    
    def optimize_feature_retrieval(self, entity_df: pd.DataFrame,
                                 features: list) -> pd.DataFrame:
        """í”¼ì²˜ ì¡°íšŒ ìµœì í™”"""
        
        # ì—”í‹°í‹° ì²­í‚¹
        chunk_size = 1000
        chunks = [entity_df[i:i+chunk_size] 
                 for i in range(0, len(entity_df), chunk_size)]
        
        results = []
        
        for i, chunk in enumerate(chunks):
            print(f"ì²˜ë¦¬ ì¤‘: ì²­í¬ {i+1}/{len(chunks)}")
            
            chunk_result = self.fs.get_historical_features(
                entity_df=chunk,
                features=features
            ).to_df()
            
            results.append(chunk_result)
        
        # ê²°ê³¼ ë³‘í•©
        final_result = pd.concat(results, ignore_index=True)
        return final_result
```

---

## âœ… ì™„ë£Œ ê¸°ì¤€

### ê¸°ëŠ¥ì  ì™„ë£Œ ê¸°ì¤€
- [ ] Feast ì„¤ì¹˜ ë° ê¸°ë³¸ ì„¤ì • ì™„ë£Œ
- [ ] ì˜í™” ì¶”ì²œ ë„ë©”ì¸ í”¼ì²˜ ë·° ì •ì˜
- [ ] ë°ì´í„° ì†ŒìŠ¤ í†µí•© ë° ë³€í™˜ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ì‹¤ì‹œê°„ í”¼ì²˜ ì„œë¹™ API êµ¬ì¶•
- [ ] ì˜¨ë¼ì¸/ì˜¤í”„ë¼ì¸ ìŠ¤í† ì–´ ì—°ë™ í™•ì¸

### ê¸°ìˆ ì  ì™„ë£Œ ê¸°ì¤€
- [ ] ì˜¨ë¼ì¸ í”¼ì²˜ ì¡°íšŒ ì‘ë‹µì‹œê°„ 10ms ì´í•˜
- [ ] ë°°ì¹˜ í”¼ì²˜ ì²˜ë¦¬ ì„±ëŠ¥ 1000 QPS ì´ìƒ
- [ ] í”¼ì²˜ ì‹¤ì²´í™” ìë™í™” êµ¬í˜„
- [ ] ëª¨ë‹ˆí„°ë§ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹œìŠ¤í…œ
- [ ] ìºì‹±ì„ í†µí•œ ì„±ëŠ¥ ìµœì í™”

### í’ˆì§ˆ ì™„ë£Œ ê¸°ì¤€
- [ ] í”¼ì²˜ ì„œë¹„ìŠ¤ ê°€ìš©ì„± 99.9% ì´ìƒ
- [ ] í”¼ì²˜ ì‹ ì„ ë„ ëª¨ë‹ˆí„°ë§ êµ¬í˜„
- [ ] ì¥ì•  ìƒí™© ëŒ€ì‘ ë§¤ë‰´ì–¼ ì‘ì„±
- [ ] ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ ë° ë¶€í•˜ í…ŒìŠ¤íŠ¸
- [ ] Feast ìš´ì˜ ê°€ì´ë“œ ë¬¸ì„œí™”

---

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„

Feast í”¼ì²˜ ìŠ¤í† ì–´ êµ¬ì¶•ì´ ì™„ë£Œë˜ë©´ 3ë‹¨ê³„ [ë²„ì „ ê´€ë¦¬ ì‹œìŠ¤í…œ](../03-version-control/README.md)ìœ¼ë¡œ ì§„í–‰í•˜ì—¬ ì½”ë“œ, ë°ì´í„°, ëª¨ë¸ì˜ ì²´ê³„ì ì¸ ë²„ì „ ê´€ë¦¬ë¥¼ êµ¬ì¶•í•©ë‹ˆë‹¤.

---

## ğŸ“š ì°¸ê³  ìë£Œ

- [Feast Official Documentation](https://docs.feast.dev/)
- [Feast GitHub Repository](https://github.com/feast-dev/feast)
- [Real-time ML with Feast](https://www.tecton.ai/blog/what-is-feast/)
- [Feature Store Best Practices](https://eugeneyan.com/writing/feature-stores/)
