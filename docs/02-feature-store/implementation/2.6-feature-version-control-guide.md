---
title: "2.6 í”¼ì²˜ ë²„ì „ ê´€ë¦¬ ê°€ì´ë“œ"
description: "í”¼ì²˜ì˜ ì§„í™”ì™€ í˜¸í™˜ì„±ì„ ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬"
author: "MLOps Team"
created: "2025-06-05"
updated: "2025-06-05"
version: "1.0"
stage: "2.6"
category: "Version Control"
tags: ["ë²„ì „ê´€ë¦¬", "í˜¸í™˜ì„±", "ìŠ¤í‚¤ë§ˆì§„í™”", "ë§ˆì´ê·¸ë ˆì´ì…˜", "ë¸Œëœì¹­ì „ëµ"]
prerequisites: ["2.5 í”¼ì²˜ ìŠ¤í† ì–´ ì™„ë£Œ", "Git", "semantic versioning"]
difficulty: "intermediate"
estimated_time: "4-6ì‹œê°„"
---

# 2.6 í”¼ì²˜ ë²„ì „ ê´€ë¦¬ ê°€ì´ë“œ

## ğŸ“‹ ê°œìš”

**ëª©í‘œ**: í”¼ì²˜ì˜ ì§„í™”ì™€ í˜¸í™˜ì„±ì„ ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬

**í•µì‹¬ ê°€ì¹˜**: ì•ˆì „í•œ í”¼ì²˜ ì§„í™”ì™€ í•˜ìœ„ í˜¸í™˜ì„± ë³´ì¥ìœ¼ë¡œ ì‹œìŠ¤í…œ ì•ˆì •ì„± í™•ë³´

---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

### ì´ë¡ ì  ëª©í‘œ
- í”¼ì²˜ ë²„ì „ ê´€ë¦¬ì˜ í•„ìš”ì„±ê³¼ ì „ëµ ì´í•´
- ìŠ¤í‚¤ë§ˆ ì§„í™”ì™€ í˜¸í™˜ì„± ì›ì¹™ í•™ìŠµ
- ë¸Œëœì¹­ ì „ëµê³¼ ë°°í¬ íŒ¨í„´ ìŠµë“

### ì‹¤ë¬´ì  ëª©í‘œ
- ì‹œë§¨í‹± ë²„ì €ë‹ ê¸°ë°˜ í”¼ì²˜ ë²„ì „ ì‹œìŠ¤í…œ êµ¬í˜„
- í˜¸í™˜ì„± ê²€ì‚¬ ë° ë§ˆì´ê·¸ë ˆì´ì…˜ ë„êµ¬ ê°œë°œ
- ì•ˆì „í•œ í”¼ì²˜ ë°°í¬ íŒŒì´í”„ë¼ì¸ êµ¬ì¶•

---

## ğŸ”§ 2.6.1 ë¸Œëœì¹­ ì „ëµ

### í”¼ì²˜ ë¸Œëœì¹˜ ëª¨ë¸

```
feature-store-branches/
â”œâ”€â”€ main/                    # í”„ë¡œë•ì…˜ ì•ˆì • ë²„ì „
â”œâ”€â”€ staging/                 # ê²€ì¦ ì¤‘ì¸ ë²„ì „
â”œâ”€â”€ development/             # ê°œë°œ ì¤‘ì¸ ë²„ì „
â””â”€â”€ experimental/            # ì‹¤í—˜ì  í”¼ì²˜
```

### ë¸Œëœì¹˜ ê´€ë¦¬ ì‹œìŠ¤í…œ

```python
from pathlib import Path
from typing import Dict, List, Any, Optional
from enum import Enum
import shutil
import json
from datetime import datetime

class BranchType(Enum):
    """ë¸Œëœì¹˜ íƒ€ì…"""
    MAIN = "main"
    STAGING = "staging"
    DEVELOPMENT = "development"
    EXPERIMENTAL = "experimental"
    FEATURE = "feature"
    HOTFIX = "hotfix"

class FeatureBranchManager:
    """í”¼ì²˜ ë¸Œëœì¹˜ ê´€ë¦¬ì"""
    
    def __init__(self, base_path: str):
        self.base_path = Path(base_path)
        self.branches_path = self.base_path / "branches"
        self.branches_path.mkdir(parents=True, exist_ok=True)
        
        # ë¸Œëœì¹˜ ë©”íƒ€ë°ì´í„° ì €ì¥ì†Œ
        self.branch_metadata_file = self.branches_path / "branch_metadata.json"
        self.branch_metadata = self._load_branch_metadata()
        
        # ê¸°ë³¸ ë¸Œëœì¹˜ ìƒì„±
        self._ensure_default_branches()
    
    def create_branch(self, branch_name: str, branch_type: BranchType,
                     parent_branch: str = "main",
                     description: str = "") -> bool:
        """ìƒˆ ë¸Œëœì¹˜ ìƒì„±"""
        
        if branch_name in self.branch_metadata:
            print(f"ë¸Œëœì¹˜ê°€ ì´ë¯¸ ì¡´ì¬: {branch_name}")
            return False
        
        # ë¶€ëª¨ ë¸Œëœì¹˜ í™•ì¸
        if parent_branch not in self.branch_metadata:
            print(f"ë¶€ëª¨ ë¸Œëœì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: {parent_branch}")
            return False
        
        # ë¸Œëœì¹˜ ë””ë ‰í† ë¦¬ ìƒì„±
        branch_path = self.branches_path / branch_name
        branch_path.mkdir(parents=True, exist_ok=True)
        
        # ë¶€ëª¨ ë¸Œëœì¹˜ì—ì„œ ë°ì´í„° ë³µì‚¬
        parent_path = self.branches_path / parent_branch
        if parent_path.exists():
            for item in parent_path.iterdir():
                if item.is_file():
                    shutil.copy2(item, branch_path)
                elif item.is_dir():
                    shutil.copytree(item, branch_path / item.name, dirs_exist_ok=True)
        
        # ë¸Œëœì¹˜ ë©”íƒ€ë°ì´í„° ìƒì„±
        self.branch_metadata[branch_name] = {
            'type': branch_type.value,
            'parent_branch': parent_branch,
            'created_at': datetime.now().isoformat(),
            'description': description,
            'last_updated': datetime.now().isoformat(),
            'status': 'active',
            'feature_count': 0,
            'commits': []
        }
        
        self._save_branch_metadata()
        
        print(f"âœ… ë¸Œëœì¹˜ ìƒì„±: {branch_name} (ë¶€ëª¨: {parent_branch})")
        return True
    
    def merge_branch(self, source_branch: str, target_branch: str,
                    merge_strategy: str = "overwrite") -> Dict[str, Any]:
        """ë¸Œëœì¹˜ ë³‘í•©"""
        
        if source_branch not in self.branch_metadata:
            return {'success': False, 'error': f'ì†ŒìŠ¤ ë¸Œëœì¹˜ ì—†ìŒ: {source_branch}'}
        
        if target_branch not in self.branch_metadata:
            return {'success': False, 'error': f'íƒ€ê²Ÿ ë¸Œëœì¹˜ ì—†ìŒ: {target_branch}'}
        
        source_path = self.branches_path / source_branch
        target_path = self.branches_path / target_branch
        
        merge_result = {
            'success': True,
            'merged_features': [],
            'conflicts': [],
            'timestamp': datetime.now().isoformat()
        }
        
        # í”¼ì²˜ë³„ ë³‘í•© ìˆ˜í–‰
        for feature_file in source_path.glob("*.parquet"):
            feature_name = feature_file.stem
            target_file = target_path / feature_file.name
            
            if target_file.exists():
                # ì¶©ëŒ ì²˜ë¦¬
                if merge_strategy == "overwrite":
                    shutil.copy2(feature_file, target_file)
                    merge_result['merged_features'].append(feature_name)
                elif merge_strategy == "skip":
                    merge_result['conflicts'].append({
                        'feature': feature_name,
                        'reason': 'file_exists',
                        'action': 'skipped'
                    })
            else:
                # ìƒˆ í”¼ì²˜ ì¶”ê°€
                shutil.copy2(feature_file, target_file)
                merge_result['merged_features'].append(feature_name)
        
        # ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸
        self.branch_metadata[target_branch]['last_updated'] = datetime.now().isoformat()
        self.branch_metadata[target_branch]['commits'].append({
            'type': 'merge',
            'source_branch': source_branch,
            'timestamp': datetime.now().isoformat(),
            'merged_features': merge_result['merged_features']
        })
        
        self._save_branch_metadata()
        
        print(f"âœ… ë¸Œëœì¹˜ ë³‘í•© ì™„ë£Œ: {source_branch} â†’ {target_branch}")
        return merge_result
    
    def list_branches(self, branch_type: Optional[BranchType] = None) -> List[Dict[str, Any]]:
        """ë¸Œëœì¹˜ ëª©ë¡ ì¡°íšŒ"""
        
        branches = []
        
        for branch_name, metadata in self.branch_metadata.items():
            if branch_type and metadata['type'] != branch_type.value:
                continue
            
            branch_info = {
                'name': branch_name,
                'type': metadata['type'],
                'parent_branch': metadata['parent_branch'],
                'created_at': metadata['created_at'],
                'last_updated': metadata['last_updated'],
                'status': metadata['status'],
                'feature_count': self._count_features_in_branch(branch_name),
                'commits_count': len(metadata['commits'])
            }
            
            branches.append(branch_info)
        
        return sorted(branches, key=lambda x: x['last_updated'], reverse=True)
    
    def _ensure_default_branches(self):
        """ê¸°ë³¸ ë¸Œëœì¹˜ë“¤ ìƒì„±"""
        
        default_branches = [
            ("main", BranchType.MAIN, None, "í”„ë¡œë•ì…˜ ì•ˆì • ë²„ì „"),
            ("staging", BranchType.STAGING, "main", "ê²€ì¦ ì¤‘ì¸ ë²„ì „"),
            ("development", BranchType.DEVELOPMENT, "main", "ê°œë°œ ì¤‘ì¸ ë²„ì „")
        ]
        
        for branch_name, branch_type, parent, description in default_branches:
            if branch_name not in self.branch_metadata:
                if parent:
                    self.create_branch(branch_name, branch_type, parent, description)
                else:
                    # main ë¸Œëœì¹˜ëŠ” íŠ¹ë³„ ì²˜ë¦¬
                    branch_path = self.branches_path / branch_name
                    branch_path.mkdir(exist_ok=True)
                    
                    self.branch_metadata[branch_name] = {
                        'type': branch_type.value,
                        'parent_branch': None,
                        'created_at': datetime.now().isoformat(),
                        'description': description,
                        'last_updated': datetime.now().isoformat(),
                        'status': 'active',
                        'feature_count': 0,
                        'commits': []
                    }
    
    def _count_features_in_branch(self, branch_name: str) -> int:
        """ë¸Œëœì¹˜ì˜ í”¼ì²˜ ê°œìˆ˜ ê³„ì‚°"""
        
        branch_path = self.branches_path / branch_name
        if not branch_path.exists():
            return 0
        
        return len(list(branch_path.glob("*.parquet")))
    
    def _load_branch_metadata(self) -> Dict[str, Any]:
        """ë¸Œëœì¹˜ ë©”íƒ€ë°ì´í„° ë¡œë“œ"""
        
        if self.branch_metadata_file.exists():
            with open(self.branch_metadata_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}
    
    def _save_branch_metadata(self):
        """ë¸Œëœì¹˜ ë©”íƒ€ë°ì´í„° ì €ì¥"""
        
        with open(self.branch_metadata_file, 'w', encoding='utf-8') as f:
            json.dump(self.branch_metadata, f, indent=2, ensure_ascii=False)
```

---

## ğŸ”§ 2.6.2 í˜¸í™˜ì„± ê´€ë¦¬

### ìŠ¤í‚¤ë§ˆ ì§„í™” ì‹œìŠ¤í…œ

```python
from dataclasses import dataclass
from typing import List, Dict, Any, Optional
import pandas as pd

@dataclass
class SchemaChange:
    """ìŠ¤í‚¤ë§ˆ ë³€ê²½ ì •ë³´"""
    change_type: str  # 'add_column', 'remove_column', 'change_type', 'rename_column'
    field_name: str
    old_value: Any = None
    new_value: Any = None
    breaking_change: bool = False
    migration_required: bool = False

class SchemaCompatibilityChecker:
    """ìŠ¤í‚¤ë§ˆ í˜¸í™˜ì„± ê²€ì‚¬ê¸°"""
    
    def __init__(self):
        self.compatibility_rules = {
            'add_column': {'breaking': False, 'migration': False},
            'remove_column': {'breaking': True, 'migration': True},
            'change_type_compatible': {'breaking': False, 'migration': False},
            'change_type_incompatible': {'breaking': True, 'migration': True},
            'rename_column': {'breaking': True, 'migration': True}
        }
    
    def check_compatibility(self, old_schema: Dict[str, Any], 
                          new_schema: Dict[str, Any]) -> Dict[str, Any]:
        """ìŠ¤í‚¤ë§ˆ í˜¸í™˜ì„± ê²€ì‚¬"""
        
        changes = self._detect_schema_changes(old_schema, new_schema)
        
        compatibility_result = {
            'is_compatible': True,
            'breaking_changes': [],
            'non_breaking_changes': [],
            'migration_required': False,
            'changes': changes,
            'recommendations': []
        }
        
        for change in changes:
            if change.breaking_change:
                compatibility_result['breaking_changes'].append(change)
                compatibility_result['is_compatible'] = False
            else:
                compatibility_result['non_breaking_changes'].append(change)
            
            if change.migration_required:
                compatibility_result['migration_required'] = True
        
        # ê¶Œì¥ì‚¬í•­ ìƒì„±
        compatibility_result['recommendations'] = self._generate_recommendations(changes)
        
        return compatibility_result
    
    def _detect_schema_changes(self, old_schema: Dict[str, Any], 
                             new_schema: Dict[str, Any]) -> List[SchemaChange]:
        """ìŠ¤í‚¤ë§ˆ ë³€ê²½ ì‚¬í•­ ê°ì§€"""
        
        changes = []
        
        old_columns = set(old_schema.get('columns', {}).keys())
        new_columns = set(new_schema.get('columns', {}).keys())
        
        # ì¶”ê°€ëœ ì»¬ëŸ¼
        added_columns = new_columns - old_columns
        for col in added_columns:
            change = SchemaChange(
                change_type='add_column',
                field_name=col,
                new_value=new_schema['columns'][col],
                breaking_change=False,
                migration_required=False
            )
            changes.append(change)
        
        # ì œê±°ëœ ì»¬ëŸ¼
        removed_columns = old_columns - new_columns
        for col in removed_columns:
            change = SchemaChange(
                change_type='remove_column',
                field_name=col,
                old_value=old_schema['columns'][col],
                breaking_change=True,
                migration_required=True
            )
            changes.append(change)
        
        # ê³µí†µ ì»¬ëŸ¼ì˜ íƒ€ì… ë³€ê²½
        common_columns = old_columns & new_columns
        for col in common_columns:
            old_type = old_schema['columns'][col].get('type')
            new_type = new_schema['columns'][col].get('type')
            
            if old_type != new_type:
                is_compatible = self._is_type_compatible(old_type, new_type)
                
                change = SchemaChange(
                    change_type='change_type_compatible' if is_compatible else 'change_type_incompatible',
                    field_name=col,
                    old_value=old_type,
                    new_value=new_type,
                    breaking_change=not is_compatible,
                    migration_required=not is_compatible
                )
                changes.append(change)
        
        return changes
    
    def _is_type_compatible(self, old_type: str, new_type: str) -> bool:
        """ë°ì´í„° íƒ€ì… í˜¸í™˜ì„± í™•ì¸"""
        
        compatible_upgrades = {
            'int8': ['int16', 'int32', 'int64', 'float32', 'float64'],
            'int16': ['int32', 'int64', 'float32', 'float64'],
            'int32': ['int64', 'float64'],
            'float32': ['float64'],
            'category': ['object']
        }
        
        return new_type in compatible_upgrades.get(old_type, [])
    
    def _generate_recommendations(self, changes: List[SchemaChange]) -> List[str]:
        """í˜¸í™˜ì„± ê°œì„  ê¶Œì¥ì‚¬í•­ ìƒì„±"""
        
        recommendations = []
        
        breaking_changes = [c for c in changes if c.breaking_change]
        
        if breaking_changes:
            recommendations.append("ì£¼ìš” ë²„ì „ ì—…ê·¸ë ˆì´ë“œ (major version) ê¶Œì¥")
            
            for change in breaking_changes:
                if change.change_type == 'remove_column':
                    recommendations.append(
                        f"ì»¬ëŸ¼ '{change.field_name}' ì œê±° ì „ deprecation ê²½ê³  ì¶”ê°€ ê¶Œì¥"
                    )
                elif change.change_type == 'change_type_incompatible':
                    recommendations.append(
                        f"ì»¬ëŸ¼ '{change.field_name}' íƒ€ì… ë³€ê²½ ì‹œ ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸ í•„ìš”"
                    )
        else:
            recommendations.append("ë§ˆì´ë„ˆ ë²„ì „ ì—…ê·¸ë ˆì´ë“œ (minor version) ê°€ëŠ¥")
        
        return recommendations

class FeatureMigrationManager:
    """í”¼ì²˜ ë§ˆì´ê·¸ë ˆì´ì…˜ ê´€ë¦¬ì"""
    
    def __init__(self, storage_path: str):
        self.storage_path = Path(storage_path)
        self.migration_scripts = {}
        
    def register_migration(self, from_version: str, to_version: str,
                          migration_func: callable):
        """ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸ ë“±ë¡"""
        
        migration_key = f"{from_version}->{to_version}"
        self.migration_scripts[migration_key] = migration_func
        
        print(f"âœ… ë§ˆì´ê·¸ë ˆì´ì…˜ ë“±ë¡: {migration_key}")
    
    def migrate_feature(self, feature_name: str, 
                       from_version: str, to_version: str,
                       data: pd.DataFrame) -> pd.DataFrame:
        """í”¼ì²˜ ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜"""
        
        migration_key = f"{from_version}->{to_version}"
        
        if migration_key not in self.migration_scripts:
            raise ValueError(f"ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: {migration_key}")
        
        migration_func = self.migration_scripts[migration_key]
        
        try:
            migrated_data = migration_func(data)
            print(f"âœ… ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ: {feature_name} ({from_version} â†’ {to_version})")
            return migrated_data
        
        except Exception as e:
            print(f"âŒ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: {feature_name} - {e}")
            raise

# ë§ˆì´ê·¸ë ˆì´ì…˜ í•¨ìˆ˜ ì˜ˆì‹œ
def migrate_user_preferences_v1_to_v2(data: pd.DataFrame) -> pd.DataFrame:
    """ì‚¬ìš©ì ì„ í˜¸ë„ í”¼ì²˜ v1 â†’ v2 ë§ˆì´ê·¸ë ˆì´ì…˜"""
    
    migrated_data = data.copy()
    
    # ìƒˆ ì»¬ëŸ¼ ì¶”ê°€
    if 'genre_diversity_score' not in migrated_data.columns:
        migrated_data['genre_diversity_score'] = 0.5  # ê¸°ë³¸ê°’
    
    # ì»¬ëŸ¼ ì´ë¦„ ë³€ê²½
    if 'pref_score' in migrated_data.columns:
        migrated_data['preference_score'] = migrated_data['pref_score']
        migrated_data.drop('pref_score', axis=1, inplace=True)
    
    # ë°ì´í„° íƒ€ì… ë³€ê²½
    if 'user_id' in migrated_data.columns:
        migrated_data['user_id'] = migrated_data['user_id'].astype('int32')
    
    return migrated_data
```

---

## ğŸ”§ 2.6.3 ì•ˆì „í•œ ë°°í¬ ì „ëµ

### ì¹´ë‚˜ë¦¬ ë°°í¬ ì‹œìŠ¤í…œ

```python
import random
from typing import List, Dict, Any
from datetime import datetime, timedelta

class CanaryDeploymentManager:
    """ì¹´ë‚˜ë¦¬ ë°°í¬ ê´€ë¦¬ì"""
    
    def __init__(self, branch_manager: FeatureBranchManager):
        self.branch_manager = branch_manager
        self.active_deployments = {}
        
    def start_canary_deployment(self, feature_name: str,
                              new_version_branch: str,
                              traffic_percentage: float = 10.0,
                              duration_hours: int = 24) -> str:
        """ì¹´ë‚˜ë¦¬ ë°°í¬ ì‹œì‘"""
        
        deployment_id = f"canary_{feature_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        deployment_config = {
            'deployment_id': deployment_id,
            'feature_name': feature_name,
            'old_version_branch': 'main',
            'new_version_branch': new_version_branch,
            'traffic_percentage': traffic_percentage,
            'start_time': datetime.now(),
            'end_time': datetime.now() + timedelta(hours=duration_hours),
            'status': 'active',
            'metrics': {
                'total_requests': 0,
                'new_version_requests': 0,
                'old_version_requests': 0,
                'error_count_new': 0,
                'error_count_old': 0,
                'avg_latency_new': 0,
                'avg_latency_old': 0
            }
        }
        
        self.active_deployments[deployment_id] = deployment_config
        
        print(f"âœ… ì¹´ë‚˜ë¦¬ ë°°í¬ ì‹œì‘: {deployment_id}")
        print(f"   í”¼ì²˜: {feature_name}")
        print(f"   ìƒˆ ë²„ì „: {new_version_branch}")
        print(f"   íŠ¸ë˜í”½ ë¹„ìœ¨: {traffic_percentage}%")
        
        return deployment_id
    
    def route_traffic(self, deployment_id: str, user_id: str) -> str:
        """íŠ¸ë˜í”½ ë¼ìš°íŒ… ê²°ì •"""
        
        if deployment_id not in self.active_deployments:
            return 'main'  # ê¸°ë³¸ ë¸Œëœì¹˜
        
        deployment = self.active_deployments[deployment_id]
        
        # ë°°í¬ ê¸°ê°„ í™•ì¸
        if datetime.now() > deployment['end_time']:
            return 'main'
        
        # íŠ¸ë˜í”½ ë¶„í•  ê²°ì •
        hash_input = f"{user_id}_{deployment_id}".encode()
        hash_value = hash(hash_input) % 100
        
        if hash_value < deployment['traffic_percentage']:
            return deployment['new_version_branch']
        else:
            return deployment['old_version_branch']
    
    def record_metrics(self, deployment_id: str, version_used: str,
                      latency_ms: float, success: bool):
        """ë©”íŠ¸ë¦­ ê¸°ë¡"""
        
        if deployment_id not in self.active_deployments:
            return
        
        deployment = self.active_deployments[deployment_id]
        metrics = deployment['metrics']
        
        metrics['total_requests'] += 1
        
        if version_used == deployment['new_version_branch']:
            metrics['new_version_requests'] += 1
            if not success:
                metrics['error_count_new'] += 1
            
            # ì´ë™ í‰ê·  ê³„ì‚°
            n = metrics['new_version_requests']
            current_avg = metrics['avg_latency_new']
            metrics['avg_latency_new'] = (current_avg * (n-1) + latency_ms) / n
            
        else:  # old version
            metrics['old_version_requests'] += 1
            if not success:
                metrics['error_count_old'] += 1
            
            n = metrics['old_version_requests']
            current_avg = metrics['avg_latency_old']
            metrics['avg_latency_old'] = (current_avg * (n-1) + latency_ms) / n
    
    def get_deployment_status(self, deployment_id: str) -> Dict[str, Any]:
        """ë°°í¬ ìƒíƒœ ì¡°íšŒ"""
        
        if deployment_id not in self.active_deployments:
            return {'error': 'ë°°í¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ'}
        
        deployment = self.active_deployments[deployment_id]
        metrics = deployment['metrics']
        
        # ì—ëŸ¬ìœ¨ ê³„ì‚°
        new_error_rate = (
            metrics['error_count_new'] / metrics['new_version_requests']
            if metrics['new_version_requests'] > 0 else 0
        )
        
        old_error_rate = (
            metrics['error_count_old'] / metrics['old_version_requests']
            if metrics['old_version_requests'] > 0 else 0
        )
        
        # ì„±ëŠ¥ ë¹„êµ
        latency_improvement = (
            (metrics['avg_latency_old'] - metrics['avg_latency_new']) 
            / metrics['avg_latency_old'] * 100
            if metrics['avg_latency_old'] > 0 else 0
        )
        
        status = {
            'deployment_id': deployment_id,
            'feature_name': deployment['feature_name'],
            'status': deployment['status'],
            'progress': self._calculate_progress(deployment),
            'metrics_summary': {
                'total_requests': metrics['total_requests'],
                'new_version_share': (
                    metrics['new_version_requests'] / metrics['total_requests'] * 100
                    if metrics['total_requests'] > 0 else 0
                ),
                'error_rate_comparison': {
                    'new_version': new_error_rate * 100,
                    'old_version': old_error_rate * 100,
                    'difference': (new_error_rate - old_error_rate) * 100
                },
                'latency_comparison': {
                    'new_version_ms': metrics['avg_latency_new'],
                    'old_version_ms': metrics['avg_latency_old'],
                    'improvement_percent': latency_improvement
                }
            },
            'health_check': self._assess_deployment_health(deployment)
        }
        
        return status
    
    def promote_or_rollback(self, deployment_id: str, 
                           decision: str = "auto") -> Dict[str, Any]:
        """ë°°í¬ ìŠ¹ê¸‰ ë˜ëŠ” ë¡¤ë°± ê²°ì •"""
        
        if deployment_id not in self.active_deployments:
            return {'error': 'ë°°í¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ'}
        
        deployment = self.active_deployments[deployment_id]
        health_check = self._assess_deployment_health(deployment)
        
        if decision == "auto":
            # ìë™ ê²°ì •
            if health_check['recommendation'] == 'promote':
                action = 'promote'
            elif health_check['recommendation'] == 'rollback':
                action = 'rollback'
            else:
                action = 'continue'
        else:
            action = decision
        
        result = {'deployment_id': deployment_id, 'action': action}
        
        if action == 'promote':
            # ìƒˆ ë²„ì „ì„ ë©”ì¸ìœ¼ë¡œ ìŠ¹ê¸‰
            merge_result = self.branch_manager.merge_branch(
                deployment['new_version_branch'],
                'main',
                'overwrite'
            )
            result['merge_result'] = merge_result
            deployment['status'] = 'promoted'
            
        elif action == 'rollback':
            # ë¡¤ë°± (ì•„ë¬´ ì‘ì—… ì—†ìŒ, ê¸°ì¡´ main ìœ ì§€)
            deployment['status'] = 'rolled_back'
            result['message'] = 'ë¡¤ë°± ì™„ë£Œ - ê¸°ì¡´ ë²„ì „ ìœ ì§€'
        
        return result
    
    def _calculate_progress(self, deployment: Dict[str, Any]) -> float:
        """ë°°í¬ ì§„í–‰ë¥  ê³„ì‚°"""
        
        start_time = deployment['start_time']
        end_time = deployment['end_time']
        current_time = datetime.now()
        
        if current_time >= end_time:
            return 100.0
        
        total_duration = (end_time - start_time).total_seconds()
        elapsed_duration = (current_time - start_time).total_seconds()
        
        return (elapsed_duration / total_duration) * 100
    
    def _assess_deployment_health(self, deployment: Dict[str, Any]) -> Dict[str, Any]:
        """ë°°í¬ ê±´ê°•ì„± í‰ê°€"""
        
        metrics = deployment['metrics']
        
        # ìµœì†Œ ìš”ì²­ ìˆ˜ í™•ì¸
        min_requests = 100
        if metrics['total_requests'] < min_requests:
            return {
                'status': 'insufficient_data',
                'recommendation': 'continue',
                'reason': f'ìš”ì²­ ìˆ˜ ë¶€ì¡± (í˜„ì¬: {metrics["total_requests"]}, ìµœì†Œ: {min_requests})'
            }
        
        # ì—ëŸ¬ìœ¨ ë¹„êµ
        new_error_rate = (
            metrics['error_count_new'] / metrics['new_version_requests']
            if metrics['new_version_requests'] > 0 else 0
        )
        
        old_error_rate = (
            metrics['error_count_old'] / metrics['old_version_requests']
            if metrics['old_version_requests'] > 0 else 0
        )
        
        # ì§€ì—°ì‹œê°„ ë¹„êµ
        latency_degradation = (
            (metrics['avg_latency_new'] - metrics['avg_latency_old'])
            / metrics['avg_latency_old'] * 100
            if metrics['avg_latency_old'] > 0 else 0
        )
        
        # ê±´ê°•ì„± íŒë‹¨
        if new_error_rate > old_error_rate * 1.5:  # ì—ëŸ¬ìœ¨ 50% ì¦ê°€
            return {
                'status': 'unhealthy',
                'recommendation': 'rollback',
                'reason': f'ì—ëŸ¬ìœ¨ ì¦ê°€ (ì‹ ê·œ: {new_error_rate:.2%}, ê¸°ì¡´: {old_error_rate:.2%})'
            }
        
        if latency_degradation > 20:  # ì§€ì—°ì‹œê°„ 20% ì¦ê°€
            return {
                'status': 'degraded',
                'recommendation': 'rollback',
                'reason': f'ì„±ëŠ¥ ì €í•˜ (ì§€ì—°ì‹œê°„ {latency_degradation:.1f}% ì¦ê°€)'
            }
        
        # ëª¨ë“  ì§€í‘œê°€ ì–‘í˜¸í•œ ê²½ìš°
        if new_error_rate <= old_error_rate and latency_degradation <= 5:
            return {
                'status': 'healthy',
                'recommendation': 'promote',
                'reason': 'ëª¨ë“  ì§€í‘œ ì–‘í˜¸'
            }
        
        return {
            'status': 'monitoring',
            'recommendation': 'continue',
            'reason': 'ì¶”ê°€ ëª¨ë‹ˆí„°ë§ í•„ìš”'
        }
```

### í†µí•© ë²„ì „ ê´€ë¦¬ ì‹œìŠ¤í…œ

```python
class FeatureVersionControl:
    """í†µí•© í”¼ì²˜ ë²„ì „ ê´€ë¦¬ ì‹œìŠ¤í…œ"""
    
    def __init__(self, base_path: str):
        self.base_path = Path(base_path)
        self.branch_manager = FeatureBranchManager(base_path)
        self.compatibility_checker = SchemaCompatibilityChecker()
        self.migration_manager = FeatureMigrationManager(base_path)
        self.canary_manager = CanaryDeploymentManager(self.branch_manager)
        
    def create_feature_version(self, feature_name: str, 
                             new_data: pd.DataFrame,
                             version_type: str = "minor",
                             branch_name: Optional[str] = None) -> Dict[str, Any]:
        """ìƒˆ í”¼ì²˜ ë²„ì „ ìƒì„±"""
        
        # ë¸Œëœì¹˜ ì´ë¦„ ìƒì„±
        if not branch_name:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            branch_name = f"feature_{feature_name}_{version_type}_{timestamp}"
        
        # ê°œë°œ ë¸Œëœì¹˜ ìƒì„±
        success = self.branch_manager.create_branch(
            branch_name, 
            BranchType.FEATURE,
            parent_branch="development",
            description=f"{feature_name}ì˜ {version_type} ë²„ì „ ì—…ë°ì´íŠ¸"
        )
        
        if not success:
            return {'success': False, 'error': 'ë¸Œëœì¹˜ ìƒì„± ì‹¤íŒ¨'}
        
        # ìƒˆ ë°ì´í„° ì €ì¥
        branch_path = self.branch_manager.branches_path / branch_name
        new_data.to_parquet(branch_path / f"{feature_name}.parquet", index=False)
        
        return {
            'success': True,
            'branch_name': branch_name,
            'feature_name': feature_name,
            'version_type': version_type
        }
    
    def deploy_feature_safely(self, feature_name: str, 
                            source_branch: str,
                            canary_percentage: float = 10.0) -> Dict[str, Any]:
        """ì•ˆì „í•œ í”¼ì²˜ ë°°í¬"""
        
        deployment_result = {}
        
        try:
            # 1. ìŠ¤í…Œì´ì§•ìœ¼ë¡œ ë³‘í•©
            staging_merge = self.branch_manager.merge_branch(
                source_branch, "staging", "overwrite"
            )
            
            if not staging_merge['success']:
                return {'success': False, 'error': 'ìŠ¤í…Œì´ì§• ë³‘í•© ì‹¤íŒ¨'}
            
            # 2. ì¹´ë‚˜ë¦¬ ë°°í¬ ì‹œì‘
            deployment_id = self.canary_manager.start_canary_deployment(
                feature_name, "staging", canary_percentage
            )
            
            deployment_result = {
                'success': True,
                'deployment_id': deployment_id,
                'stage': 'canary_started',
                'message': f'ì¹´ë‚˜ë¦¬ ë°°í¬ ì‹œì‘ë¨ ({canary_percentage}% íŠ¸ë˜í”½)'
            }
            
        except Exception as e:
            deployment_result = {
                'success': False,
                'error': str(e),
                'stage': 'deployment_failed'
            }
        
        return deployment_result
    
    def get_feature_history(self, feature_name: str) -> Dict[str, Any]:
        """í”¼ì²˜ ë³€ê²½ ì´ë ¥ ì¡°íšŒ"""
        
        history = {
            'feature_name': feature_name,
            'branches': [],
            'deployments': []
        }
        
        # ë¸Œëœì¹˜ë³„ ì´ë ¥
        for branch_name, metadata in self.branch_manager.branch_metadata.items():
            branch_path = self.branch_manager.branches_path / branch_name
            feature_file = branch_path / f"{feature_name}.parquet"
            
            if feature_file.exists():
                history['branches'].append({
                    'branch_name': branch_name,
                    'branch_type': metadata['type'],
                    'last_updated': metadata['last_updated'],
                    'commits': metadata['commits']
                })
        
        # ë°°í¬ ì´ë ¥
        for deployment_id, deployment in self.canary_manager.active_deployments.items():
            if deployment['feature_name'] == feature_name:
                history['deployments'].append({
                    'deployment_id': deployment_id,
                    'status': deployment['status'],
                    'start_time': deployment['start_time'].isoformat(),
                    'traffic_percentage': deployment['traffic_percentage']
                })
        
        return history
```

---

## âœ… ì™„ë£Œ ê¸°ì¤€

### ê¸°ëŠ¥ì  ì™„ë£Œ ê¸°ì¤€
- [ ] ë¸Œëœì¹˜ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„ ì™„ë£Œ
- [ ] ìŠ¤í‚¤ë§ˆ í˜¸í™˜ì„± ê²€ì‚¬ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ë§ˆì´ê·¸ë ˆì´ì…˜ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ì¹´ë‚˜ë¦¬ ë°°í¬ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] í†µí•© ë²„ì „ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„

### ê¸°ìˆ ì  ì™„ë£Œ ê¸°ì¤€
- [ ] ë¸Œëœì¹˜ ìƒì„±/ë³‘í•© ê¸°ëŠ¥ ì™„ì „ ë™ì‘
- [ ] í˜¸í™˜ì„± ê²€ì‚¬ ì •í™•ë„ 95% ì´ìƒ
- [ ] ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸ ë“±ë¡/ì‹¤í–‰ ì‹œìŠ¤í…œ
- [ ] ì¹´ë‚˜ë¦¬ ë°°í¬ íŠ¸ë˜í”½ ë¼ìš°íŒ… êµ¬í˜„
- [ ] ìë™ ìŠ¹ê¸‰/ë¡¤ë°± ê²°ì • ì‹œìŠ¤í…œ

### í’ˆì§ˆ ì™„ë£Œ ê¸°ì¤€
- [ ] ë¸Œëœì¹˜ ê´€ë¦¬ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±
- [ ] í˜¸í™˜ì„± ê²€ì‚¬ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‘ì„±
- [ ] ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸ ê²€ì¦ ì‹œìŠ¤í…œ
- [ ] ì¹´ë‚˜ë¦¬ ë°°í¬ ì‹œë®¬ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸
- [ ] ë²„ì „ ê´€ë¦¬ ì›Œí¬í”Œë¡œìš° ë¬¸ì„œí™”

---

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„

ì™„ë£Œ í›„ [2.7 Feast í”¼ì²˜ ìŠ¤í† ì–´ í†µí•©](./2.7-feast-feature-store-integration-guide.md)ë¡œ ì§„í–‰í•˜ì—¬ ì˜¤í”ˆì†ŒìŠ¤ í”¼ì²˜ ìŠ¤í† ì–´ë¥¼ í™œìš©í•œ ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ í”¼ì²˜ ê´€ë¦¬ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•©ë‹ˆë‹¤.

---

## ğŸ“š ì°¸ê³  ìë£Œ

- [Semantic Versioning](https://semver.org/)
- [Git Branching Strategies](https://nvie.com/posts/a-successful-git-branching-model/)
- [Schema Evolution Patterns](https://docs.confluent.io/platform/current/schema-registry/avro.html)
- [Canary Deployment Best Practices](https://martinfowler.com/bliki/CanaryRelease.html)
