---
title: "2.1 í”¼ì²˜ ì—”ì§€ë‹ˆì–´ë§ ë¡œì§ ê°œë°œ ê°€ì´ë“œ"
description: "TMDBPreProcessor ê¸°ë°˜ í™•ì¥ ê°€ëŠ¥í•œ í”¼ì²˜ ìƒì„± ì‹œìŠ¤í…œ êµ¬ì¶•"
author: "MLOps Team"
created: "2025-06-05"
updated: "2025-06-05"
version: "1.0"
stage: "2.1"
category: "Feature Engineering"
tags: ["í”¼ì²˜ì—”ì§€ë‹ˆì–´ë§", "TMDBPreProcessor", "ë°ì´í„°ì¦ê°•", "ì‹œê°„ê¸°ë°˜í”¼ì²˜", "í†µê³„ì í”¼ì²˜"]
prerequisites: ["1ë‹¨ê³„ ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ", "Python ê¸°ì´ˆ", "pandas/numpy"]
difficulty: "intermediate"
estimated_time: "4-6ì‹œê°„"
---

# 2.1 í”¼ì²˜ ì—”ì§€ë‹ˆì–´ë§ ë¡œì§ ê°œë°œ ê°€ì´ë“œ

## ğŸ“‹ ê°œìš”

**ëª©í‘œ**: TMDBPreProcessorë¥¼ ê¸°ë°˜ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥í•œ í”¼ì²˜ ìƒì„± ì‹œìŠ¤í…œ êµ¬ì¶•

**í•µì‹¬ ê°€ì¹˜**: ML ëª¨ë¸ì˜ ì„±ëŠ¥ì„ ì¢Œìš°í•˜ëŠ” ê³ í’ˆì§ˆ í”¼ì²˜ë¥¼ ì²´ê³„ì ìœ¼ë¡œ ìƒì„±

---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

### ì´ë¡ ì  ëª©í‘œ
- í”¼ì²˜ ì—”ì§€ë‹ˆì–´ë§ì˜ í•µì‹¬ ì›ë¦¬ ì´í•´
- ë„ë©”ì¸ ì§€ì‹ì„ í”¼ì²˜ë¡œ ë³€í™˜í•˜ëŠ” ë°©ë²• ìŠµë“
- ì‹œê°„ì /í†µê³„ì /ìƒí˜¸ì‘ìš© í”¼ì²˜ì˜ ì„¤ê³„ ì›ì¹™ í•™ìŠµ

### ì‹¤ë¬´ì  ëª©í‘œ
- TMDBPreProcessor í´ë˜ìŠ¤ í™•ì¥ ë° ê³ ë„í™”
- ë‹¤ì–‘í•œ ìœ í˜•ì˜ í”¼ì²˜ ìƒì„± ë¡œì§ êµ¬í˜„
- í”¼ì²˜ í’ˆì§ˆ ê²€ì¦ ì‹œìŠ¤í…œ êµ¬ì¶•

---

## ğŸ”§ 2.1.1 TMDBPreProcessor í´ë˜ìŠ¤ í™•ì¥

### í˜„ì¬ ê¸°ë³¸ êµ¬ì¡° ë¶„ì„

ê¸°ì¡´ TMDBPreProcessorì˜ í•µì‹¬ ê¸°ëŠ¥:
```python
class TMDBPreProcessor:
    def __init__(self, movies: list, user_count=100, max_select_count=20):
        # ì„¤ì • ì´ˆê¸°í™”
    
    @staticmethod
    def augmentation(movie):
        # ì˜í™” í‰ì  ê¸°ë°˜ ë°ì´í„° ì¦ê°•: pow(2, rating)
        
    def generate_watch_second(self, rating):
        # í‰ì  ê¸°ë°˜ ì‹œì²­ ì‹œê°„ ìƒì„± ë¡œì§
        
    def selection(self, user_id, features):
        # ì‚¬ìš©ìë³„ ì˜í™” ì„ íƒ ì‹œë®¬ë ˆì´ì…˜
        
    def run(self):
        # ì „ì²´ ì „ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ ì‹¤í–‰
```

### í™•ì¥ëœ êµ¬ì¡° ì„¤ê³„

```python
class AdvancedTMDBPreProcessor:
    def __init__(self, movies: list, config: dict):
        self.movies = movies
        self.config = config
        self.feature_registry = {}
        self.validators = []
        self.transformers = {}
        
    def register_feature(self, name: str, extractor_func: callable, 
                        dependencies: list = None):
        """í”¼ì²˜ ì¶”ì¶œ í•¨ìˆ˜ë¥¼ ë“±ë¡"""
        self.feature_registry[name] = {
            'extractor': extractor_func,
            'dependencies': dependencies or [],
            'metadata': {}
        }
    
    def add_validator(self, validator: callable):
        """í”¼ì²˜ ê²€ì¦ í•¨ìˆ˜ ì¶”ê°€"""
        self.validators.append(validator)
    
    def extract_all_features(self):
        """ì˜ì¡´ì„± ìˆœì„œì— ë”°ë¼ ëª¨ë“  í”¼ì²˜ ì¶”ì¶œ"""
        # ì˜ì¡´ì„± ê·¸ë˜í”„ ê¸°ë°˜ ì‹¤í–‰ ìˆœì„œ ê²°ì •
        # ê° í”¼ì²˜ ì¶”ì¶œ ë° ê²€ì¦
        pass
```

### í•µì‹¬ í”¼ì²˜ ìƒì„± ë¡œì§ ê°œì„ 

#### **ë°ì´í„° ì¦ê°• ê³ ë„í™”**
```python
def advanced_augmentation(self, movie: dict, strategy: str = "rating_based"):
    """ë‹¤ì–‘í•œ ì „ëµì˜ ë°ì´í„° ì¦ê°•"""
    
    strategies = {
        'rating_based': lambda x: int(pow(2, x['vote_average'])),
        'popularity_based': lambda x: int(x['popularity'] / 10),
        'hybrid': lambda x: int(pow(1.5, x['vote_average']) * (x['popularity'] / 50))
    }
    
    if strategy not in strategies:
        raise ValueError(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì¦ê°• ì „ëµ: {strategy}")
    
    count = strategies[strategy](movie)
    
    # ìµœì†Œ/ìµœëŒ€ ì œí•œ ì ìš©
    min_count = self.config.get('min_augmentation', 1)
    max_count = self.config.get('max_augmentation', 100)
    
    return max(min_count, min(count, max_count))
```

#### **ì‹œì²­ ì‹œê°„ ëª¨ë¸ë§ ê°œì„ **
```python
def generate_sophisticated_watch_time(self, movie: dict, user_profile: dict):
    """ì‚¬ìš©ì í”„ë¡œí•„ê³¼ ì˜í™” íŠ¹ì„±ì„ ê³ ë ¤í•œ ì‹œì²­ ì‹œê°„ ìƒì„±"""
    
    base_duration = movie.get('runtime', 120) * 60  # ì´ˆ ë‹¨ìœ„
    rating = movie['vote_average']
    popularity = movie['popularity']
    
    # ì‚¬ìš©ì ì„ í˜¸ë„ ë°˜ì˜
    genre_preference = self._calculate_genre_preference(
        movie['genre_ids'], user_profile
    )
    
    # ì‹œì²­ ì™„ë£Œ í™•ë¥  ê³„ì‚°
    completion_prob = self._calculate_completion_probability(
        rating, popularity, genre_preference
    )
    
    # ì‹¤ì œ ì‹œì²­ ì‹œê°„ ê³„ì‚°
    if completion_prob > 0.8:
        # ë†’ì€ í™•ë¥ ë¡œ ì™„ì‹œì²­
        watch_time = base_duration * random.uniform(0.9, 1.0)
    elif completion_prob > 0.5:
        # ì¤‘ê°„ ì§€ì ê¹Œì§€ ì‹œì²­
        watch_time = base_duration * random.uniform(0.4, 0.8)
    else:
        # ì´ˆë°˜ì— ì´íƒˆ
        watch_time = base_duration * random.uniform(0.1, 0.3)
    
    return int(watch_time)

def _calculate_genre_preference(self, genre_ids: list, user_profile: dict):
    """ì‚¬ìš©ìì˜ ì¥ë¥´ ì„ í˜¸ë„ ê³„ì‚°"""
    preferences = user_profile.get('genre_preferences', {})
    
    if not genre_ids:
        return 0.5  # ê¸°ë³¸ê°’
    
    scores = [preferences.get(str(gid), 0.5) for gid in genre_ids]
    return sum(scores) / len(scores)

def _calculate_completion_probability(self, rating: float, popularity: float, 
                                   genre_pref: float):
    """ì˜í™” ì™„ì‹œì²­ í™•ë¥  ê³„ì‚°"""
    # ê°€ì¤‘ í‰ê· ìœ¼ë¡œ í™•ë¥  ê³„ì‚°
    prob = (rating * 0.4 + (popularity / 100) * 0.3 + genre_pref * 0.3) / 10
    return max(0.1, min(0.95, prob))  # 0.1-0.95 ë²”ìœ„ë¡œ ì œí•œ
```

---

## ğŸ”§ 2.1.2 ê³ ê¸‰ í”¼ì²˜ ì—”ì§€ë‹ˆì–´ë§

### ì‹œê°„ ê¸°ë°˜ í”¼ì²˜

#### **ì¶œì‹œì—°ë„ë³„ íŠ¸ë Œë“œ ë¶„ì„**
```python
def extract_temporal_features(self, movies: list):
    """ì‹œê°„ ê¸°ë°˜ í”¼ì²˜ ì¶”ì¶œ"""
    
    # ì˜í™”ë³„ ì¶œì‹œì—°ë„ ì¶”ì¶œ
    for movie in movies:
        release_date = movie.get('release_date', '')
        if release_date:
            year = int(release_date[:4])
            movie['release_year'] = year
            movie['decade'] = (year // 10) * 10
            movie['era'] = self._classify_era(year)
    
    # ì—°ë„ë³„ ì¸ê¸°ë„ íŠ¸ë Œë“œ ê³„ì‚°
    year_popularity = {}
    for movie in movies:
        year = movie.get('release_year')
        if year:
            if year not in year_popularity:
                year_popularity[year] = []
            year_popularity[year].append(movie['popularity'])
    
    # ê° ì˜í™”ì— ì—°ë„ë³„ ìƒëŒ€ì  ì¸ê¸°ë„ ì¶”ê°€
    for movie in movies:
        year = movie.get('release_year')
        if year and year in year_popularity:
            year_avg = sum(year_popularity[year]) / len(year_popularity[year])
            movie['relative_popularity'] = movie['popularity'] / year_avg
    
    return movies

def _classify_era(self, year: int):
    """ì˜í™” ì‹œëŒ€ ë¶„ë¥˜"""
    if year < 1970:
        return 'classic'
    elif year < 1990:
        return 'vintage'  
    elif year < 2010:
        return 'modern'
    else:
        return 'contemporary'
```

#### **ê³„ì ˆì„± íŒ¨í„´ ëª¨ë¸ë§**
```python
def generate_seasonal_preferences(self, user_profile: dict):
    """ì‚¬ìš©ìë³„ ê³„ì ˆì  ì¥ë¥´ ì„ í˜¸ë„ ìƒì„±"""
    
    seasonal_patterns = {
        'spring': {'romance': 1.2, 'drama': 1.1, 'comedy': 1.0},
        'summer': {'action': 1.3, 'adventure': 1.2, 'comedy': 1.1},
        'autumn': {'thriller': 1.2, 'drama': 1.2, 'horror': 1.1},
        'winter': {'drama': 1.3, 'romance': 1.1, 'family': 1.2}
    }
    
    # ì‚¬ìš©ìì˜ ê¸°ë³¸ ì„ í˜¸ë„ì— ê³„ì ˆ ê°€ì¤‘ì¹˜ ì ìš©
    current_season = self._get_current_season()
    pattern = seasonal_patterns.get(current_season, {})
    
    adjusted_preferences = user_profile.get('genre_preferences', {}).copy()
    for genre, weight in pattern.items():
        if genre in adjusted_preferences:
            adjusted_preferences[genre] *= weight
    
    return adjusted_preferences

def _get_current_season(self):
    """í˜„ì¬ ê³„ì ˆ ë°˜í™˜ (ì‹œë®¬ë ˆì´ì…˜ìš©)"""
    import random
    return random.choice(['spring', 'summer', 'autumn', 'winter'])
```

### í†µê³„ì  í”¼ì²˜

#### **ì˜í™”ë³„ í‰ì  ë¶„í¬ ë¶„ì„**
```python
def calculate_rating_distribution_features(self, movies: list):
    """ì˜í™”ë³„ í‰ì  ë¶„í¬ í†µê³„ í”¼ì²˜ ê³„ì‚°"""
    
    all_ratings = [movie['vote_average'] for movie in movies]
    
    # ì „ì²´ ë¶„í¬ í†µê³„
    mean_rating = np.mean(all_ratings)
    std_rating = np.std(all_ratings)
    
    for movie in movies:
        rating = movie['vote_average']
        
        # Z-score (ì •ê·œí™” ì ìˆ˜)
        movie['rating_zscore'] = (rating - mean_rating) / std_rating
        
        # ë°±ë¶„ìœ„ ìˆœìœ„
        movie['rating_percentile'] = (
            sum(1 for r in all_ratings if r <= rating) / len(all_ratings)
        )
        
        # ì¹´í…Œê³ ë¦¬ ë¶„ë¥˜
        if rating >= 8.0:
            movie['rating_category'] = 'excellent'
        elif rating >= 7.0:
            movie['rating_category'] = 'good'
        elif rating >= 6.0:
            movie['rating_category'] = 'average'
        else:
            movie['rating_category'] = 'poor'
    
    return movies
```

#### **ì¥ë¥´ë³„ í†µê³„ ê³„ì‚°**
```python
def calculate_genre_statistics(self, movies: list):
    """ì¥ë¥´ë³„ í†µê³„ì  í”¼ì²˜ ê³„ì‚°"""
    
    # ì¥ë¥´ë³„ ë°ì´í„° ìˆ˜ì§‘
    genre_stats = {}
    for movie in movies:
        for genre_id in movie.get('genre_ids', []):
            if genre_id not in genre_stats:
                genre_stats[genre_id] = {
                    'ratings': [],
                    'popularity': [],
                    'count': 0
                }
            
            genre_stats[genre_id]['ratings'].append(movie['vote_average'])
            genre_stats[genre_id]['popularity'].append(movie['popularity'])
            genre_stats[genre_id]['count'] += 1
    
    # ì¥ë¥´ë³„ í†µê³„ ê³„ì‚°
    for genre_id, data in genre_stats.items():
        data['avg_rating'] = np.mean(data['ratings'])
        data['avg_popularity'] = np.mean(data['popularity'])
        data['rating_std'] = np.std(data['ratings'])
        data['popularity_std'] = np.std(data['popularity'])
    
    # ê° ì˜í™”ì— ì¥ë¥´ í†µê³„ í”¼ì²˜ ì¶”ê°€
    for movie in movies:
        genre_features = {
            'avg_genre_rating': 0,
            'avg_genre_popularity': 0,
            'genre_diversity': len(movie.get('genre_ids', []))
        }
        
        if movie.get('genre_ids'):
            ratings = [genre_stats[gid]['avg_rating'] 
                      for gid in movie['genre_ids'] 
                      if gid in genre_stats]
            popularities = [genre_stats[gid]['avg_popularity'] 
                           for gid in movie['genre_ids'] 
                           if gid in genre_stats]
            
            if ratings:
                genre_features['avg_genre_rating'] = np.mean(ratings)
            if popularities:
                genre_features['avg_genre_popularity'] = np.mean(popularities)
        
        movie.update(genre_features)
    
    return movies, genre_stats
```

### ìƒí˜¸ì‘ìš© í”¼ì²˜

#### **ì‚¬ìš©ì-ì¥ë¥´ ì¹œí™”ë„**
```python
def calculate_user_genre_affinity(self, interactions: list):
    """ì‚¬ìš©ìë³„ ì¥ë¥´ ì¹œí™”ë„ ê³„ì‚°"""
    
    user_genre_interactions = {}
    
    # ì‚¬ìš©ìë³„ ì¥ë¥´ ìƒí˜¸ì‘ìš© ìˆ˜ì§‘
    for interaction in interactions:
        user_id = interaction['user_id']
        movie_genres = interaction.get('movie_genres', [])
        watch_time = interaction['watch_seconds']
        rating = interaction['rating']
        
        if user_id not in user_genre_interactions:
            user_genre_interactions[user_id] = {}
        
        for genre in movie_genres:
            if genre not in user_genre_interactions[user_id]:
                user_genre_interactions[user_id][genre] = {
                    'total_watch_time': 0,
                    'total_ratings': 0,
                    'count': 0
                }
            
            user_genre_interactions[user_id][genre]['total_watch_time'] += watch_time
            user_genre_interactions[user_id][genre]['total_ratings'] += rating
            user_genre_interactions[user_id][genre]['count'] += 1
    
    # ì¹œí™”ë„ ì ìˆ˜ ê³„ì‚°
    user_affinities = {}
    for user_id, genres in user_genre_interactions.items():
        user_affinities[user_id] = {}
        
        for genre, stats in genres.items():
            avg_watch_time = stats['total_watch_time'] / stats['count']
            avg_rating = stats['total_ratings'] / stats['count']
            
            # ì •ê·œí™”ëœ ì¹œí™”ë„ ì ìˆ˜ (0-1 ë²”ìœ„)
            affinity_score = (avg_rating / 10.0 * 0.6 + 
                            min(avg_watch_time / 7200, 1.0) * 0.4)
            
            user_affinities[user_id][genre] = affinity_score
    
    return user_affinities
```

#### **ì˜í™”-ì˜í™” ìœ ì‚¬ë„**
```python
def calculate_movie_similarity(self, movies: list):
    """ì˜í™” ê°„ ìœ ì‚¬ë„ ê³„ì‚°"""
    
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.preprocessing import MultiLabelBinarizer
    
    # ì¥ë¥´ ê¸°ë°˜ ìœ ì‚¬ë„
    genres_list = [movie.get('genre_ids', []) for movie in movies]
    mlb = MultiLabelBinarizer()
    genre_matrix = mlb.fit_transform(genres_list)
    
    genre_similarity = cosine_similarity(genre_matrix)
    
    # ë©”íƒ€ë°ì´í„° ê¸°ë°˜ ìœ ì‚¬ë„
    features = []
    for movie in movies:
        feature_vector = [
            movie['vote_average'] / 10.0,  # ì •ê·œí™”ëœ í‰ì 
            min(movie['popularity'] / 100, 1.0),  # ì •ê·œí™”ëœ ì¸ê¸°ë„
            movie.get('release_year', 2000) / 2025.0  # ì •ê·œí™”ëœ ì¶œì‹œì—°ë„
        ]
        features.append(feature_vector)
    
    metadata_similarity = cosine_similarity(features)
    
    # ê°€ì¤‘ í‰ê· ìœ¼ë¡œ ìµœì¢… ìœ ì‚¬ë„ ê³„ì‚°
    final_similarity = (genre_similarity * 0.7 + metadata_similarity * 0.3)
    
    # ê° ì˜í™”ì— ìœ ì‚¬ ì˜í™” ì •ë³´ ì¶”ê°€
    for i, movie in enumerate(movies):
        similarities = final_similarity[i]
        
        # ìê¸° ìì‹  ì œì™¸í•˜ê³  ìƒìœ„ 5ê°œ ìœ ì‚¬ ì˜í™” ì¸ë±ìŠ¤
        similar_indices = np.argsort(similarities)[-6:-1][::-1]
        
        movie['similar_movies'] = [
            {
                'movie_id': movies[idx]['id'],
                'similarity': similarities[idx]
            }
            for idx in similar_indices
        ]
        
        movie['avg_similarity_score'] = np.mean([
            similarities[idx] for idx in similar_indices
        ])
    
    return movies, final_similarity
```

---

## ğŸ”§ 2.1.3 í”¼ì²˜ ê²€ì¦ ì‹œìŠ¤í…œ

### í†µê³„ì  ê²€ì¦

#### **í”¼ì²˜ ë¶„í¬ ì •ìƒì„± í™•ì¸**
```python
def validate_feature_distribution(self, feature_data: pd.DataFrame):
    """í”¼ì²˜ ë¶„í¬ì˜ í†µê³„ì  ì •ìƒì„± ê²€ì¦"""
    
    validation_results = {}
    
    for column in feature_data.select_dtypes(include=[np.number]).columns:
        series = feature_data[column].dropna()
        
        if len(series) < 10:
            continue
        
        results = {
            'column': column,
            'count': len(series),
            'missing_ratio': feature_data[column].isnull().sum() / len(feature_data),
            'mean': series.mean(),
            'std': series.std(),
            'skewness': series.skew(),
            'kurtosis': series.kurtosis()
        }
        
        # ì •ê·œì„± ê²€ì • (Shapiro-Wilk test for small samples)
        if len(series) <= 5000:
            from scipy.stats import shapiro
            stat, p_value = shapiro(series)
            results['normality_test'] = {
                'statistic': stat,
                'p_value': p_value,
                'is_normal': p_value > 0.05
            }
        
        # ì´ìƒì¹˜ íƒì§€ (IQR ë°©ë²•)
        Q1 = series.quantile(0.25)
        Q3 = series.quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        
        outliers = series[(series < lower_bound) | (series > upper_bound)]
        results['outliers'] = {
            'count': len(outliers),
            'ratio': len(outliers) / len(series),
            'values': outliers.tolist()[:10]  # ìµœëŒ€ 10ê°œë§Œ ì €ì¥
        }
        
        validation_results[column] = results
    
    return validation_results
```

#### **ìƒê´€ê´€ê³„ ë¶„ì„**
```python
def analyze_feature_correlations(self, feature_data: pd.DataFrame, 
                                threshold: float = 0.9):
    """í”¼ì²˜ ê°„ ìƒê´€ê´€ê³„ ë¶„ì„ ë° ë‹¤ì¤‘ê³µì„ ì„± ê²€ì‚¬"""
    
    # ìˆ˜ì¹˜í˜• í”¼ì²˜ë§Œ ì„ íƒ
    numeric_features = feature_data.select_dtypes(include=[np.number])
    
    # ìƒê´€ê³„ìˆ˜ í–‰ë ¬ ê³„ì‚°
    correlation_matrix = numeric_features.corr()
    
    # ë†’ì€ ìƒê´€ê´€ê³„ í”¼ì²˜ ìŒ ì°¾ê¸°
    high_correlations = []
    for i in range(len(correlation_matrix.columns)):
        for j in range(i+1, len(correlation_matrix.columns)):
            corr_value = correlation_matrix.iloc[i, j]
            if abs(corr_value) > threshold:
                high_correlations.append({
                    'feature1': correlation_matrix.columns[i],
                    'feature2': correlation_matrix.columns[j],
                    'correlation': corr_value
                })
    
    # VIF (Variance Inflation Factor) ê³„ì‚°
    from statsmodels.stats.outliers_influence import variance_inflation_factor
    
    vif_data = pd.DataFrame()
    vif_data["Feature"] = numeric_features.columns
    vif_data["VIF"] = [
        variance_inflation_factor(numeric_features.values, i) 
        for i in range(len(numeric_features.columns))
    ]
    
    # ë‹¤ì¤‘ê³µì„ ì„± ë¬¸ì œê°€ ìˆëŠ” í”¼ì²˜ ì‹ë³„ (VIF > 10)
    multicollinear_features = vif_data[vif_data["VIF"] > 10]["Feature"].tolist()
    
    return {
        'correlation_matrix': correlation_matrix,
        'high_correlations': high_correlations,
        'vif_scores': vif_data,
        'multicollinear_features': multicollinear_features
    }
```

### ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê²€ì¦

#### **ë„ë©”ì¸ ì§€ì‹ ê¸°ë°˜ ê·œì¹™**
```python
def validate_business_logic(self, movies: list, interactions: list):
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë„ë©”ì¸ ì§€ì‹ ê¸°ë°˜ ë°ì´í„° ê²€ì¦"""
    
    validation_errors = []
    
    # ì˜í™” ë°ì´í„° ê²€ì¦
    for movie in movies:
        movie_id = movie.get('id')
        
        # í‰ì  ë²”ìœ„ ê²€ì¦ (0-10)
        rating = movie.get('vote_average', 0)
        if not 0 <= rating <= 10:
            validation_errors.append({
                'type': 'rating_range',
                'movie_id': movie_id,
                'message': f'í‰ì ì´ ìœ íš¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: {rating}'
            })
        
        # ì¸ê¸°ë„ ìŒìˆ˜ ê²€ì¦
        popularity = movie.get('popularity', 0)
        if popularity < 0:
            validation_errors.append({
                'type': 'negative_popularity',
                'movie_id': movie_id,
                'message': f'ì¸ê¸°ë„ê°€ ìŒìˆ˜: {popularity}'
            })
        
        # ì¶œì‹œì¼ ê²€ì¦
        release_date = movie.get('release_date', '')
        if release_date:
            try:
                from datetime import datetime
                release_year = int(release_date[:4])
                current_year = datetime.now().year
                
                if release_year < 1900 or release_year > current_year + 2:
                    validation_errors.append({
                        'type': 'invalid_release_year',
                        'movie_id': movie_id,
                        'message': f'ë¹„í˜„ì‹¤ì ì¸ ì¶œì‹œì—°ë„: {release_year}'
                    })
            except (ValueError, IndexError):
                validation_errors.append({
                    'type': 'invalid_date_format',
                    'movie_id': movie_id,
                    'message': f'ì˜ëª»ëœ ë‚ ì§œ í˜•ì‹: {release_date}'
                })
    
    # ìƒí˜¸ì‘ìš© ë°ì´í„° ê²€ì¦
    for interaction in interactions:
        user_id = interaction.get('user_id')
        movie_id = interaction.get('content_id')
        watch_time = interaction.get('watch_seconds', 0)
        rating = interaction.get('rating', 0)
        
        # ì‹œì²­ ì‹œê°„ í˜„ì‹¤ì„± ê²€ì¦ (ìµœëŒ€ 8ì‹œê°„)
        if watch_time > 8 * 3600:
            validation_errors.append({
                'type': 'unrealistic_watch_time',
                'user_id': user_id,
                'movie_id': movie_id,
                'message': f'ë¹„í˜„ì‹¤ì ì¸ ì‹œì²­ ì‹œê°„: {watch_time}ì´ˆ'
            })
        
        # ì‹œì²­ ì‹œê°„ ìŒìˆ˜ ê²€ì¦
        if watch_time < 0:
            validation_errors.append({
                'type': 'negative_watch_time',
                'user_id': user_id,
                'movie_id': movie_id,
                'message': f'ìŒìˆ˜ ì‹œì²­ ì‹œê°„: {watch_time}'
            })
        
        # í‰ì  ë²”ìœ„ ê²€ì¦
        if not 0 <= rating <= 10:
            validation_errors.append({
                'type': 'invalid_rating',
                'user_id': user_id,
                'movie_id': movie_id,
                'message': f'ìœ íš¨í•˜ì§€ ì•Šì€ í‰ì : {rating}'
            })
    
    return validation_errors
```

#### **ë ˆì´ë¸” ë¦¬í‚¤ì§€ ë°©ì§€**
```python
def check_label_leakage(self, features: pd.DataFrame, target: pd.Series):
    """íƒ€ê²Ÿ ë³€ìˆ˜ì™€ì˜ ë ˆì´ë¸” ë¦¬í‚¤ì§€ ê²€ì‚¬"""
    
    leakage_warnings = []
    
    # ìˆ˜ì¹˜í˜• í”¼ì²˜ì™€ íƒ€ê²Ÿì˜ ìƒê´€ê´€ê³„ í™•ì¸
    for column in features.select_dtypes(include=[np.number]).columns:
        correlation = features[column].corr(target)
        
        # ë„ˆë¬´ ë†’ì€ ìƒê´€ê´€ê³„ëŠ” ë¦¬í‚¤ì§€ ê°€ëŠ¥ì„±
        if abs(correlation) > 0.95:
            leakage_warnings.append({
                'feature': column,
                'correlation': correlation,
                'severity': 'high',
                'message': f'íƒ€ê²Ÿê³¼ ê³¼ë„í•˜ê²Œ ë†’ì€ ìƒê´€ê´€ê³„: {correlation:.3f}'
            })
        elif abs(correlation) > 0.8:
            leakage_warnings.append({
                'feature': column,
                'correlation': correlation,
                'severity': 'medium',
                'message': f'íƒ€ê²Ÿê³¼ ë†’ì€ ìƒê´€ê´€ê³„ ì£¼ì˜: {correlation:.3f}'
            })
    
    # ë¯¸ë˜ ì •ë³´ ì‚¬ìš© ê²€ì‚¬ (ì‹œê°„ ê¸°ë°˜)
    time_features = [col for col in features.columns 
                    if any(keyword in col.lower() 
                          for keyword in ['future', 'next', 'after', 'tomorrow'])]
    
    if time_features:
        leakage_warnings.append({
            'feature': time_features,
            'severity': 'high',
            'message': 'ë¯¸ë˜ ì •ë³´ë¥¼ í¬í•¨í•œ í”¼ì²˜ ë°œê²¬'
        })
    
    return leakage_warnings
```

---

## âœ… ì™„ë£Œ ê¸°ì¤€

### ê¸°ëŠ¥ì  ì™„ë£Œ ê¸°ì¤€
- [ ] TMDBPreProcessor í™•ì¥ í´ë˜ìŠ¤ êµ¬í˜„ ì™„ë£Œ
- [ ] ì‹œê°„ ê¸°ë°˜ í”¼ì²˜ 5ê°œ ì´ìƒ ìƒì„±
- [ ] í†µê³„ì  í”¼ì²˜ 5ê°œ ì´ìƒ ìƒì„±  
- [ ] ìƒí˜¸ì‘ìš© í”¼ì²˜ 3ê°œ ì´ìƒ ìƒì„±
- [ ] í”¼ì²˜ ê²€ì¦ ì‹œìŠ¤í…œ êµ¬í˜„

### ê¸°ìˆ ì  ì™„ë£Œ ê¸°ì¤€
- [ ] í”¼ì²˜ ë“±ë¡ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ì˜ì¡´ì„± ê¸°ë°˜ ì‹¤í–‰ ìˆœì„œ ê´€ë¦¬
- [ ] ë³‘ë ¬ ì²˜ë¦¬ ì§€ì›
- [ ] ë©”ëª¨ë¦¬ íš¨ìœ¨ì  ì²˜ë¦¬
- [ ] ì„¤ì • íŒŒì¼ ê¸°ë°˜ ê´€ë¦¬

### í’ˆì§ˆ ì™„ë£Œ ê¸°ì¤€
- [ ] ëª¨ë“  í”¼ì²˜ì— ëŒ€í•œ í†µê³„ì  ê²€ì¦ í†µê³¼
- [ ] ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê²€ì¦ 100% í†µê³¼
- [ ] ë ˆì´ë¸” ë¦¬í‚¤ì§€ ê²€ì‚¬ í†µê³¼
- [ ] ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ ìˆ˜ë¦½
- [ ] ë¬¸ì„œí™” ì™„ë£Œ

---

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„

ì™„ë£Œ í›„ [2.2 í”¼ì²˜ ìƒì„± íŒŒì´í”„ë¼ì¸ êµ¬ì¶•](./2.2-feature-pipeline-construction-guide.md)ìœ¼ë¡œ ì§„í–‰í•˜ì—¬ ìƒì„±ëœ í”¼ì²˜ë“¤ì„ ìë™í™”ëœ íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.

---

## ğŸ“š ì°¸ê³  ìë£Œ

- [Feature Engineering for Machine Learning](https://www.oreilly.com/library/view/feature-engineering-for/9781491953235/)
- [Pandas Documentation](https://pandas.pydata.org/docs/)
- [Scikit-learn Feature Engineering](https://scikit-learn.org/stable/modules/preprocessing.html)
- [Domain Knowledge in Feature Engineering](https://towardsdatascience.com/)
